\documentclass[slovak, bachelorpractice]{diploma}

% Packages (balíky makier)
\usepackage[autostyle=true, czech=quotes]{csquotes} % korektná sadzba úvozoviek, podpora pre balík biblatex
\usepackage[backend=biber, style=iso-numeric, alldates=iso]{biblatex} % bibliografia
\usepackage{dcolumn} % stĺpce tabuľky s číselnými hodnotami
\usepackage{subfig} % makrá pre "podobrázky" a "podtabuľky"
\usepackage[csharp]{diplomalst} % sádzanie 

% ------------------------------------------------------

% Nový druh tabuľkového stĺpca, v ktorom sú čísla zarovnané podľa desetinnej čiarky
\newcolumntype{d}[1]{D{,}{,}{#1}}

% Odstranenie warningov s underfull vbox
\raggedbottom

% ------------------------------------------------------

% Vlastný jazyk YML
\lstdefinelanguage{yml} {
  morekeywords={variables, GIT_CLONE_PATH, GIT_CLEAN_FLAGS, unity-build, stage, only, script, tags},
  alsoletter=-,
}

% Vlastny štýl Batch
\lstdefinestyle{Batch} {
  morekeywords={SET, @ECHO, ECHO, IF, EXIT, START, ELSE, GTR},
  deletekeywords={var, is}
}

% Definované vlastné metódy, triedy a príslušné farby
\makeatletter
\lst@InstallKeywords k{methods}{methodstyle}\slshape{methodstyle}{}ld
\lst@InstallKeywords k{classes}{classstyle}\slshape{classstyle}{}ld
\makeatother

\definecolor{methods}{rgb}{.45, .33, .12}
\definecolor{classes}{rgb}{.12, .40, .16}
\definecolor{words}{rgb}{.17, .57, .69}

\lstset {
 moremethods={ExecutePost, GetUri, SendIssue, SerializeObject, ReadToEnd, Parse, OnUpdate, StartCreateReport, ZipAndSendToLinkManager, Log, StartCoroutine, LocalIPAddress, ToString, Exists, Delete, WriteAllText, OpenURL, WaitForSeconds, EnumerateFiles, Contains, AddFile, Save, ReadAllBytes, Send_MantisReport, ToBase64String, AcceptTcpClient, GetStream, Read, GetString, CreateReport, GetWindowRect, GetActiveWindow, GetUnityBounds, pictureBoxBcg_MouseDown, pictureBoxBcg_MouseUp, pictureBoxBcg_MouseMove, Invalidate, DrawLine, InvokePowershellScript, AddScript, Invoke, Select, ToArray, Create, Format, ToHex, Matches, FromJson, ReadAllText, PrintListToJsonString, ToJson, LoadAssetAtPath, FindProperty, OnEnable, OnInspectorGUI, ApplyModifiedProperties, PropertyField, SetUpScenes, Add, GetValues, IsSelected, ToInt32, BuildWindows, BuildPlayer, GetBuildOptions, FindEdges, Raycast, IsNotSimilarToRef, Translate, DestroyImmediate, FindDistanceAndRotation, IsTrue, FindRotation, LookRotation, NeedToReverseDirection, CreatePrimitive, Distance, GetComponent, PointInAABB, InverseTransformPoint, Cross},
 methodstyle=\bfseries\color{methods},
 moreclasses={Issue, JsonConvert, JObject, Keyboard, Debug, HBTLink_Manager, GameConfiguration, File, Application, ZipFile, Directory, SearchOption, Convert, TcpClient, NetworkStream, Encoding, Rect, Screen, IntPtr, MouseEventArgs, Point, PowerShell, GitLogger, Regex, Message, Content, Serialize, MenuItem, DllImport, AssetDatabase, BuildSettings, SerializedProperty, CustomEditor, EditorGUILayout, Editor, BuildSettingsEditor, Enum, Array, List, Scene, BuildPlayerOptions, BuildTarget, BuildTargetGroup, BuildResult, BuildReport, BuildPipeline, WindowsSettings, Vector3, GameObject, HideFlags, Transform, Physics, RaycastHit, Object, PrimitiveType, Quaternion, BoxCollider, Assert},
 classstyle = \bfseries\color{classes},
 morekeywords={endif, var, yield, get, set}
}

% ------------------------------------------------------

%Zásady pro vypracování
%1. Student vykoná individuální praxi ve firmě: Perun Creative s.r.o.
%2. Struktura závěrečné zprávy:
%    a) Popis odborného zaměření firmy, u které student vykonal odbornou praxi a popis pracovního zařazení studenta.
%     b) Seznam úkolů zadaných studentovi v průběhu odborné praxe s  vyjádřením jejich časové náročnosti.
%     c) Zvolený postup řešení zadaných úkolů.
%     d) Teoretické a praktické znalosti a dovednosti získané v průběhu studia uplatněné studentem v průběhu odborné praxe.
%     e) Znalosti či dovednosti scházející studentovi v průběhu odborné praxe.
%     f) Dosažené výsledky v průběhu odborné praxe a její celkové zhodnocení.

% Poznámka    
%Programátor, počítačová hra
%   Student se v průběhu bakalářské praxe bude podílet na vývoji počítačové hry Hobo: Tough Life. Primární náplní stážisty bude optimalizace stávajícího kódu (detekování úzkých hrdel v časově kritických situacích a jejich následné zefektivnění), kooperace s QA oddělením (vyhodnocování chybových reportů, realizace oprav a vývoj pomocných nástrojů dle požadavků testerů) a portace hry na nové platformy (mac, linux a herní konzole). V rámci praxe se stážista seznámí s herním enginem Unity, setká se s jazykem C# a zapojí se do práce v kolektivu (práce s verzovacím systémem, komunikace a podílení se na řešeních v rámci týmu).

% ------------------------------------------------------

% Titulná strana
\ThesisAuthor{Miroslav Kačeriak}
\ThesisSupervisor{Ing. Pavel Dohnálek, Ph.D.}
\SubmissionYear{2021}

% ------------------------------------------------------

% Abstrakty
\CzechAbstract{Cieľom tejto bakalárskej práce je popísať absolvovanie odbornej praxe v českom nezávislom hernom štúdiu Perun Creative. Prvá časť si kladie za cieľ charakterizovať štúdio ako také a uviesť základnú klasifikáciu vyvíjaného produktu, teda počítačovej hry Hobo: Tough Life. Následne by som chcel špecifikovať moje pracovné zaradenie v rámci štruktúry spoločnosti a uviesť najdôležitejšie technológie, s ktorými som mal možnosť pracovať. Hlavnú časť tejto práce tvorí popis realizácie konkrétnych projektov. Tie sa týkali najmä vývoja pomocných nástrojov, optimalizácie a prevodu hry na iné platformy, ale aj implementácie konkrétnych herných mechaník. Záver je potom venovaný celkovému zhodnoteniu absolvovanej odbornej praxe so zameraním na uplatnené a novonadobudnuté znalosti a zručnosti.}

\CzechKeywords{Unity engine, C\#, herný vývoj, automatizácia, optimalizácia, vývojárske nástroje}

\EnglishAbstract{Main purpose of this bachelor thesis is to describe how my individual professional practise in czech indie game studio Perun Creative went. First part aims to characterize the studio as such and give a basic classification of the developed product, i.e. the computer game Hobo: Tough Life. Afterwards, I would like to specify my position within the company structure and mention the most important technologies that I had the opportunity to work with. The main part of this thesis is dealing with the implementation of specific projects. These were mainly focused on the creation of development tools, optimization and porting of the game to other platforms, but also the implementation of some game mechanics. The conclusion is then aimed to the overall evaluation of the completed individual professional practice with focus on applied and newly acquired knowledge and skills.}

\EnglishKeywords{Unity engine, C\#, game development, automatisation, optimization, development tools}

% ------------------------------------------------------

% Poďakovanie
\Acknowledgement{Rád by som na tomto mieste poďakoval mojím dvom kolegom, a zároveň zakladateľom herného štúdia Perun Creative, Bc. Jánovi Polachovi a Bc. Jirkovi Vašicovi za prejavenú dôveru, trpezlivosť a ochotu pomôcť počas absolvovania odbornej praxe. Poďakovanie patrí aj mojej priateľke za podnetné rady a postrehy poskytnuté pri písaní tejto práce.}

% ------------------------------------------------------

% Skratky
\AddAcronym{API}{Application Programming Interface}
\AddAcronym{CD}{Continuous Delivery}
\AddAcronym{CD}{Continuous Deployment}
\AddAcronym{CI}{Continuous Integration}
\AddAcronym{CLR}{Common Language Runtime}
\AddAcronym{DLL}{Dynamic Link Library}
\AddAcronym{EOS}{Epic Online Services}
\AddAcronym{HTTPS}{Hypertext Transfer Protocol Secure}
\AddAcronym{IL}{Intermediate Language}
\AddAcronym{IP}{Internet Protocol}
\AddAcronym{JIT}{Just-In-Time}
\AddAcronym{JSON}{JavaScript Object Notation}
\AddAcronym{LINQ}{Language-Integrated Query}
\AddAcronym{LFS}{Large File Storage}
\AddAcronym{MSS}{Maximum Segment Size}
\AddAcronym{MTU}{Maximum transmission unit}
\AddAcronym{NPC}{Non-playable Character}
\AddAcronym{OS}{Operating System}
\AddAcronym{PC}{Personal Computer}
\AddAcronym{QA}{Quality Assurance}
\AddAcronym{REST}{Representational State Transfer}
\AddAcronym{RPG}{Role Playing Game}
\AddAcronym{SSH}{Secure Shell}
\AddAcronym{SSL}{Secure Sockets Layer}
\AddAcronym{TCP}{Transmission Control Protocol}
\AddAcronym{URL}{Uniform Resource Locator}
\AddAcronym{WPF}{Windows Presentation Foundation}
\AddAcronym{XML}{eXtensible Markup Language}

% ------------------------------------------------------

% Literatúra
\addbibresource{literature.bib}

% ------------------------------------------------------

% Samotný dokument
\begin{document}
\MakeTitlePages

% Chapter 1
\chapter{Úvod}
\label{sec:Introduction}
V rámci mojej odbornej praxe som dostal možnosť nahliadnuť za oponu herného vývoja v českom nezávislom štúdiu Perun Creative. Nakoľko sa o hry a herný priemysel dlhodobo zaujímam, táto firma a jej tvorba mi bola vopred známa. Aj po prednáške jej dvoch spoluzakladateľov a zároveň programátorov, ktorá sa uskutočnila v priestoroch Vysokej školy báňskej, som bol stále prekvapený vysokou technologickou úrovňou ich prvého projektu. Firmu som chcel kontaktovať so žiadosťou o prácu nezávisle od odbornej praxe, no keď som sa dozvedel, že už niekoho práve na odbornú prax hľadajú, rozhodol som sa to využiť a načerpať touto cestou dnes veľmi cenené skúsenosti z reálneho vývoja. Pracovnému pohovoru predchádzalo zaslanie programátorského portfólia zloženého zo školských ale aj vlastných prác. Samotný pohovor potom prebiehal online s oboma programátormi \mbox{Bc. Jánom} Polachom a Bc. Jirkou Vašicou, ktorí sa po jeho úspešnom zvládnutí stali mojimi kolegami.

Do firmy som nastúpil na konci životného cyklu projektu, takže som sa nemohol podieľať na vývoji základných herných mechaník. Naopak to znamenalo nutnosť dôkladne sa s celým projektom zoznámiť a pochopiť, ako jednotlivé časti fungujú. Počas praxe som sa podieľal na vývoji širokej škály väčších či menších projektov. Tie sa týkali primárne oblastí ako sú automatizácia a zefektívnenie rôznych postupov pri testovaní či vývoji, nasadenie projektu, prevod hry na iné platformy, optimalizácia a došlo aj na vývoj určitých herných mechaník. Pri riešení jednotlivých problémov mi okrem kolegov boli nápomocné aj rôzne teoretické znalosti nadobudnuté počas vysokoškolského štúdia.

% Section 2
\chapter{Popis firmy a pracovného zaradenia}
\label{sec:Firm and me}
% TODO: Overit info u Jirky
\section{Popis firmy a vyvíjaného produktu}
\label{sec:Firm}
Perun Creative s.r.o je české nezávislé herné štúdio, ktoré od roku 2015 vyvíja počítačovú hru Hobo: Tough Life \cite{Perun}.

Hra samotná by sa dala charakterizovať ako RPG z mestského prostredia, kde sa hráč ocitne v role bezdomovca. Ústrednou hernou mechanikou je snaha prežiť v nehostinnom prostredí ulice. Okrem prežitia na hráča čaká aj pútavý príbeh a možnosť hrať kooperatívne až s troma ďalšími hráčmi \cite{Hobo}. Hobo: Tough Life v súčasnosti vychádza na platformách Microsoft Windows a Linux. V budúcnosti sa počíta aj s vydaním na konzolách novej a starej generácie. 

Štúdio Perun Creative má aktuálne dve pobočky. Prvá sa nachádza v Ostrave a jej osadenstvo tvoria výhradne programátori. Pobočka v Olomouci naopak slúži pre menej technicky zameranú časť firmy a síce pre grafika, herného dizajnéra a komunitného manažéra. Štúdio tvorí menej ako desať vývojárov, svojou veľkosťou sa teda radí k menším. Využíva však aj služby externých pracovníkov prípadne spoločností špecializovaných na testovanie, zvukovú stránku hry a v neposlednom rade aj na preklad textov do rôznych svetových jazykov.
\vspace{-5pt}
\begin{figure}[!htbp]
	\centering
	\includegraphics[width=0.8\textwidth]{Pictures/logoNew.jpg}
	\vspace{-5pt}
	\caption{Logo spoločnosti Perun Creative}
	\label{pic:perunLogo}
\end{figure}
\section{Pracovné zaradenie}
\label{sec:Me}
Môj prínos štúdiu Perun Creative spočíval hlavne vo vývoji pomocných nástrojov pre QA oddelenie a ostatných programátorov. Primárnym zameraním bola teda automatizácia a zefektívnenie jednotlivých interných postupov. Do tejto kategórie by som zaradil projekty ako automatizované zostavenie hry na serveri, zefektívnenie spôsobu nahlasovania chýb nájdených v hre, prípadne prepracovanie spôsobu importovania objektov zo starej verzie projektu do novej. K zefektívneniu práce rozhodne prispel aj návrh a implementácia systému klávesových skratiek v hernom engine Unity (bližšie popísanom v sekcií \ref{sec:Unity}) či  program na vytvorenie tzv. \mbox{\enquote{Patch notes}}. Ten bol primárne určený pre testerov, do budúcna sa však plánuje jeho využitie aj pri informovaní hráčov o novinkách v rámci hry.

Okrem vyššie uvedených projektov som pracoval na novom systéme líhania hráčskej postavy, optimalizácií a uvedeniu hry na OS Linux, prevode online zložky hry z platformy Steam na platformu EOS, prípadne ďalších menších projektoch.
% End of section 2

% Section 3
\chapter{Použité technológie}
\label{sec:Tech}
V nasledujúcej kapitole by som rád v krátkosti zhrnul najdôležitejšie technológie, s ktorými som sa v rámci odbornej praxe stretol. Niektoré som aktívne využíval počas celého obdobia praxe a ich osvojovanie teda prebiehalo organicky. Iné boli špecifické pre konkrétny projekt a danú technológiu som si musel naštudovať počas jeho realizácie. V niektorých prípadoch bolo nutné sa zoznámiť s viacerými technológiami, aby som bol schopný posúdiť ich výhody a nevýhody pri nasadení na konkrétny projekt a vybrať tú správnu. Informácie som poväčšine čerpal z dokumentácií k daným technológiám, nie vždy však bola ich úroveň dostatočná.

\section{Programovací jazyk C\# a architektúra .NET}
\label{sec:CsharpDotNet}
C\# je objektovo orientovaný, typovo bezpečný programovací jazyk umožňujúci vytvárať aplikácie v .NET ekosystéme. Syntax jazyka C\# vychádza z programovacích jazykov C a C++. Narozdiel od nich však ponúka vyššiu úroveň abstrakcie, ktorá sa prejavuje napríklad na úrovni správy pamäte \cite{CSharpLang}. Táto vlastnosť spolu s ďalšími robí z jazyka C\#  voľbu číslo jedna pre začínajúcich programátorov, ktorí by si chceli skúsiť herný vývoj na vlastnej koži.

Architektúra .NET potom ponúka okrem virtuálneho stroja CLR, ktorý vykonáva JIT kompiláciu IL kódu do strojových inštrukcií, aj sadu veľmi užitočných knižníc. Tieto knižnice sú organizované do menných priestorov a poskytujú širokú škálu metód vhodných napríklad na prácu so súbormi či sieťovou infraštruktúrou. Veľmi užitočné sú aj nástroje na syntaktickú analýzu XML prípadne platforma Windows Forms \cite{CSharpLang}. Tá sa v rámci mojej odbornej praxe v spoločnosti Perun Creative ukázala byť vhodná hlavne na rýchlu tvorbu vývojárskych nástrojov. Kvôli limitáciám tejto technológie sa však v budúcnosti plánuje prechod na systém WPF.

\section{Unity Engine}
\label{sec:Unity}
Unity Engine je platforma pre tvorbu 2D a 3D interaktívneho obsahu renderovaného v reálnom čase \cite{Unity}. Najväčšie uplatnenie nachádza pri tvorbe malých až stredne veľkých hier, čoraz častejšie sa sa však využíva aj v iných odvetviach ako napríklad automobilový či filmový priemysel. Je dostupný pre operačné systémy Windows, Linux a Mac OS. Distribuuje sa zdarma pre študentov alebo jednotlivcov do určitého finančného obratu a za ročný poplatok pre firmy, ktorého výška závisí od rôznych faktorov. Samotný engine je napísaný v jazyku C++ a umožňuje vývoj obsahu v jazyku C\# (bližšie popísanom v sekcií \ref{sec:CsharpDotNet}) pre širokú škálu platforiem, čo znázorňuje \mbox{obrázok \ref{pic:UnityPlatforms}}.

\begin{figure}[!htbp]
	\centering
	\includegraphics[width=1\textwidth]{Pictures/platforms.png}
	\caption{Platformy podporované herným enginom Unity \cite{UnityMultiplatform}}
	\label{pic:UnityPlatforms}
\end{figure}

\section{Verzovací systém Git}
\label{sec:Git}
Git je open source distribuovaný systém na správu verzií vyvinutý Linusom Thorvaldsom a komunitou okolo OS Linux v roku 2005 \cite{ProGit}. Umožňuje vrátiť celý projekt alebo vybrané časti do predchádzajúceho stavu, porovnávať zmeny v súboroch či efektívnu kolaboráciu viacerých vývojárov na spoločnom projekte. Každý člen tímu má k dispozícií kompletný repozitár vrátane histórie jednotlivých súborov, čo pridáva ďalšiu vrstvu ochrany proti výpadkom a poruchám hardvéru. Po každom spustení príkazu \textit{commit} sa uloží aktuálny stav projektu, ktorý je možné spätne dohľadať v prípade nejakého problému.

S gitom je možné pracovať priamo z príkazového riadku ale pre väčšie projekty ako je aj hra Hobo: Tough Life môže byť takýto prístup značne nepraktický. Veľmi to však závisí od konkrétnych preferencií vývojára. Na trhu existuje množstvo programov tretích strán, ktoré umožňujú pracovať s gitom z užívateľského rozhrania. Jedným takým je aj nástroj Sourcetree, s ktorým som v rámci mojej odbornej praxe pracoval na dennej báze.

Nakoľko git samotný nie je dobre prispôsobený na správu verzií veľkých súborov, bolo nutné využívať aj jeho rozšírenie Git LFS. 
\section{GitLab CI/CD}
\label{sec:GitLab}
Gitlab CI/CD je súčasť nástroja Gitlab a slúži na vývoj softvéru prostredníctvom kontinuálnych metód definovaných podľa \cite{Cicd} ako:
\begin{itemize}
  \item \textbf{Continuous Integration (CI)} - pre každé pridanie zmien do repozitára je možné automatizovane spustiť sadu skriptov, ktorých účelom je projekt zostaviť či otestovať.
  \item \textbf{Continuous Delivery (CD)} - pridáva ďalšiu vrstvu nad rámec CI, umožňuje zostavený a otestovaný kód nasadiť, vyžaduje to však manuálnu akciu.
  \item \textbf{Continuous Deployment (CD)} - funguje podobne ako Continuous Delivery ale nasadenie prebieha automaticky.
\end{itemize}
Spoločnou filozofiou týchto metód je teda po každej iteratívnej zmene v projekte kód zostaviť, otestovať a prípadne aj nasadiť. Hlavnou výhodou takého prístupu je redukovanie množstva chýb, ktoré by sa inak dostávali do ďalších iterácií a mohli by spôsobiť problémy, keby neboli odchytené v zárodku. Zároveň si kladú za cieľ znížiť potrebu manuálneho zásahu do jednotlivých automatizovaných procesov na minimum.

V rámci mojej odbornej praxe som sa stretol hlavne s metódou CI. Možnosti automatizovaného testovania hry touto metódou sú veľmi obmedzené, o to viac je ale užitočné automatizované zostavenie na serveri. Zostavenie tohto typu projektu na pracovnej stanici je typicky náročne ako časovo tak aj na výpočtový výkon a do značnej miery teda spomaľuje vývoj ako taký. Bolo teda logickým krokom zamerať sa v rámci optimalizácie interných procesov aj na tento aspekt.

\begin{figure}[!htbp]
	\centering
	\includegraphics[width=.9\textwidth]{Pictures/gitlab.png}
	\vspace{-15pt}
	\caption{Princíp fungovania služby Gitab CI/CD \cite{Cicd}}
	\label{pic:Gitlab}
\end{figure}

% Section 4
\chapter{Zadané projekty a ich riešenia}
\label{sec:Projects}
V tejto kapitole by som rád podrobne prebral niektoré konkrétne projekty na ktorých som v rámci mojej odbornej praxe pracoval. Poradie v akom budú prezentované nutne neodzrkadľuje poradie ich vypracovania ale budú usporiadané do logických celkov podľa typu projektu. 

Nie vždy bolo možné presne určiť časovú náročnosť nakoľko niektoré z projektov boli vyvíjané inkrementálne podľa spätnej väzby QA oddelenia alebo nových požiadaviek od ostatných programátorov.

\section{Vývoj pomocných nástrojov pre QA oddelenie a programátorov}
\label{sec:QACode}
\subsection{Evidovanie chybových záznamov (Mantis Report)}
\label{sec:Report}
\textbf{Časová náročnosť:} \\ Nasadenie: 8 dní, pridanie ďalšej funkcionality podľa požidaviek: spolu 8 dní.\\
\textbf{Úvod do problému:} \\ Ako som spomenul v sekcií \ref{sec:GitLab} možnosti automatizovaného testovania hry tohto rozsahu sú na rozdiel od bežného softvéru značne obmedzené. Veľké štúdiá si vytvárajú vlastné nástroje založené na umelej inteligencií, nikdy sa to však úplne neobíde bez ľudí z QA oddelenia ľudovo nazývaných aj ako testeri. Úlohou testera je teda hrať celú hru alebo jej určené časti, nájsť a následne ohlásiť nájdené chyby. 

Takéto ohlásenie chyby je značne neefektívny proces nakoľko na pozadí zahŕňa hneď niekoľko ďalších krokov ako minimalizácia hry, otvorenie stránky so službou Mantis Bug Tracker, nahranie snímky obrazovky a nakoniec aj samotné vyplnenie detailov reportu. Niektoré z týchto detailov sa navyše medzi jednotlivými reportmi nemenia ako napríklad informácie o platforme či operačnom systéme. Ručné vyplnenie reportu znázorňuje obrázok \ref{pic:Mantis}.
Táto neefektívnosť samozrejme priamo úmerne rastie s počtom nájdených chýb, čo môžu byť aj vyššie jednotky denne. Mojou úlohou bolo teda optimalizovať tento postup. \\
\textbf{Navrhované riešenia:} \\ Nakoľko bola toto moja prvá úloha v rámci odbornej praxe, mal som len minimálne skúsenosti s webovými technológiami ako je REST API a celkovo klient-server architektúrou, navrhol som riešenie postavené na nejakom nástroji na automatizovanie webového prehliadača. Takýmto nástrojom je napríklad Selenium WebDriver, s ktorým som sa stretol pri práci na vlastných projektoch. Ten je veľmi obľúbený napríklad pri testovaní webových aplikácií. Dokázal by zapnúť webový prehliadač, či už s užívateľským rozhraním alebo bez, otvoriť požadovanú stránku a vyplniť detaily reportu za užívateľa. V spojení s nejakým vlastným nástrojom na ukladanie snímky obrazovky, prípadne nástrojom, ktorý by testerovi umožnil vypísať zhrnutie či popis reportu priamo v hre by sa naozaj jednalo o relatívne dobré riešenie. Po užívateľovi by to ale vyžadovalo nutnosť inštalácie nejakého konkrétneho prehliadača v požadovanej verzií, aby bola zaistená správna kompatibilita a veľmi pravdepodobne by sa v budúcnosti objavili aj ďalšie problémy s nasadením či používaním. 

Po preskúmaní ďalších možností a následnej porade s kolegami som sa teda rozhodol dať prednosť riešeniu postavenému na už spomínanom REST API a ak by sa to ukázalo ako nerealizovateľné spätne sa vrátiť k môjmu prvému nápadu.
\vspace{-5pt}
\begin{figure}[!htbp]
	\centering
	\setlength{\fboxsep}{0pt}
	\setlength{\fboxrule}{1pt}
	\fbox {
		\includegraphics[width=0.68\textwidth]{Pictures/mantis.png}
	}
	\caption{Ručné vloženie záznamu o chybe do služby Mantis Bug Tracker}
	\label{pic:Mantis}
\end{figure} \\
\textbf{Realizácia:} \\ Pri preskúmavaní možností založených na REST API som narazil na open source projekt MantisSharp \cite{MantisSharp}. Po zoznámení sa s týmto projektom a niekoľkými pokusmi ho \enquote{ohnúť} pre účely môjho projektu som sa rozhodol, že bude jednoduchšie napísať si aplikáciu sám. Využil som k tomu dve triedy z projektu MantisSharp, a síce \textit{RestClient} a \textit{MantisClient}, ktoré som následne ešte ďalej modifikoval. Trieda \textit{RestClient} vykonáva najnižšiu úroveň komunikácie so serverom a síce odosiela GET a POST žiadosti. Trieda \textit{MantisClient} má potom dve úlohy. Na jednej strane prijíma dáta z mojej aplikácie, zabalí ich do formy vhodnej pre transport a následne ich predá triede \textit{RestClient} na odoslanie metódou POST. Na strane druhej transformuje dáta získané zo servera pomocou metódy GET do C\# tried vhodných na následné použitie. Tento postup pridáva určitý level abstrakcie do celej aplikácie.

Problematiku odosielania dát na server som sa rozhodol demonštrovať na pridaní nového reportu vo výpise \ref{src:SendIssue}. Aplikácia vytvorí na základe vstupných dát inštanciu triedy \textit{Issue}, ktorú predá metóde \textit{SendIssue}. Tá ju následne zabalí ako JSON objekt a ďalej predá v metóde \textit{ExecutePost} na finálne odoslanie. Získavanie dát funguje obdobne len opačným smerom. 

Služba Mantis Bug Tracker po úspešnom pridaní nového reportu tento report vráti v odpovedi, čo som ďalej využil na informovanie užívateľa o úspešnom zaevidovaní, ktoré som doplnil o serverom pridelený identifikátor.
\vspace{10pt}
\begin{lstlisting}[label=src:SendIssue,caption={Programové odoslanie záznamu o chybe do služby Mantis Bug Tracker}]
public int SendIssue(Issue issue) {
	string uri = this.GetUri(issuesUri);
	int id = -1;

	restClient.ExecutePost(uri, () => JsonConvert.SerializeObject(issue),
        reader => {
            string answerFromServer = reader.ReadToEnd();
            JObject obj = JObject.Parse(answerFromServer);
            id = (int)obj["issue"]["id"];
        });

    return id;
}
\end{lstlisting}
Server spočiatku na všetky žiadosti reagoval chybou \enquote{401 Unauthorized}. Po dôkladnom preskúmaní problému sa ukázalo, že chyba je na strane serveru a bolo nutné zasiahnuť do jeho kódu. Nakoľko som k tomuto kódu nemal prístup, požiadal som kolegu, či by mi s tým mohol pomôcť. Ukázalo sa, že server filtroval všetky požiadavky, ktoré sa pokúšali o autorizáciu pomocou tzv. \enquote{Bearer tokenu}. Spoločne sa nám tento problém však podarilo vyriešiť. 

Systém nahlasovania reportov mal byť pôvodne implementovaný ako súčasť hry. To sa ale ukázalo ako problematické z hľadiska zachytávania užívateľského vstupu v Unity engine. V praxi by to znamenalo, že ak by užívateľ popisoval chybu napríklad do nejakého textového poľa, hra samotná by naďalej vykonávala akcie na základe stlačených kláves. Rozhodli sme sa teda začleniť tento systém do už existujúceho vývojárskeho nástroja s názvom HoboThor. Tento nástroj je veľmi komplexný a jeho popis by bol nad rámec tejto kapitoly.

Logika aplikácie bola teda rozdelená do dvoch častí. Časť, s ktorou interaguje užívateľ bola realizovaná ako Windows Forms aplikácia začlenená do nástroja HoboThor a časť, ktorá túto aplikáciu spustí bola implementovaná priamo do hry a vyvolá sa stlačením klávesovej skratky Shift + F11, ak je hra spustená s podporou vývojárskych nástrojov. 

Kontrola, či boli stlačené konkrétne klávesy musí prebiehať každú snímku, aby sa zabezpečilo, že odchytenie prebehne úspešne. Kód zabezpečujúci túto funkcionalitu bol teda vložený do metódy \textit{OnUpdate} triedy \textit{ReportingManager}, čo znázorňuje výpis \ref{src:OnUpdate}. 

Projekt Hobo: Tough Life do veľkej miery stojí na hierarchickej štruktúre tried, tzv. \enquote{Manageroch}, ktorí, ako názov napovedá obstarávajú určité časti aplikácie. Metóda \textit{OnUpdate} triedy \textit{ReportingManager} je teda každú snímku volaná inou triedou, ktorá je vyššie v hierarchickej štruktúre projektu. Na najvyššom stupni hierarchie potom stojí trieda \textit{MainManager}. Tá obsahuje metódu \textit{Update}, ktorá je priamo volaná natívnym C++ kódom enginu Unity a táto metóda potom obsahuje volania metód \textit{OnUpdate} jednotlivých \enquote{Managerov}, ktorí jej náležia.
\vspace{10pt}
\begin{lstlisting}[label=src:OnUpdate,caption={Odchytenie stlačenia klávesovej skratky v spustenej hre}]
public void OnUpdate() {
    if (Keyboard.current.f11Key.wasPressedThisFrame) {
        if (Keyboard.current.leftShiftKey.isPressed) {
            screenSaved = false;
            StartCoroutine(StartCreateReport());
            return;
        }
    }

    if (screenSaved) {
        ZipAndSendToLinkManager();
        screenSaved = false;
    }
}
\end{lstlisting}

Kód vo výpise \ref{src:OnUpdate} teda každú snímku testuje, či bola stlačená klávesa F11 a to práve v tom danom snímku. Toto zabezpečí, že sa blok kódu tejto podmienky vykoná len raz, bez ohľadu na to, ako dlho užívateľ danú klávesu držal stlačenú. Ak je popri tom stlačená aj klávesa Shift, spustí sa tzv. \enquote{Coroutine}. V tomto prípade je ňou mnou definovaná metóda \textit{StartCreateReport}. Výhoda korutiny spočíva v možnosti pozastaviť vykonávanie svojho kódu. Pozastavenie môže byť na programátorom definovanú dobu alebo do doby než nastane určitá udalosť. V tomto prípade bolo tou udalosťou kompletné vykreslenie aktuálneho snímku a to z dôvodu zachytenia tohto snímku ako obrázku.

Metóda \textit{StartCreateReport} má za úlohu zozbierať rôzne dáta o aplikácií alebo systéme, na ktorom je spustená. Ide o dáta ako verzia aplikácie, pozícia a rotácia kamery v momente vyvolania akcie či posledný záznam v logovacom systéme. Tieto dáta sú následne spolu so spomínanou snímkou obrazovky a naposledy uloženým postupom hrou uložené na disk. Zložka, do ktorej sú súbory uložené závisí od toho, či je hra spustená z editoru Unity alebo samostatne. Takéto vetvenie kódu sa realizuje pomocou direktívy UNITY\_EDITOR, ktorá je spolu s ďalšími platformovo závislými direktívami definovaná samotným editorom. Jednoduchý príklad použitia takýchto direktív demonštruje výpis \ref{src:Pragma}. Nakoľko táto zložka obsahuje celú históriu reportov, jednotlivé reporty majú poradové čísla a každý ďalší dostane pridelené poradové číslo o jedna väčšie ako ten predchádzajúci.
\vspace{10pt}
\begin{lstlisting}[label=src:Pragma,caption={Ukážka použitia direktívy UNITY\_EDITOR}]
#if UNITY_EDITOR
	Debug.Log("Editor");                
#else
    Debug.Log("Standalone");             
#endif
\end{lstlisting}

Následne sa logika aplikácie delí na dve vetvy. Prvá obstaráva vytvorenie lokálneho reportu, druhá vzdialeného. Možnosť vzdialeného nahlasovania chýb, teda odoslanie reportu z PC na ktorom hra nie je spustená bola pridaná až neskôr v súvislosti s prevodom hry na iné platformy. Oba spôsoby odoslania reportu potom demonštruje výpis \ref{src:Report}.

Odoslanie reportu na server z lokálneho PC pokračuje vytvorením tzv. \enquote{Mantis argumentu}. Ide o textový súbor, ktorého obsah je cesta k naposledy vytvorenému reportu. Ten je uložený do zložky, kde sa nachádza spúšťací súbor nástroja HoboThor. Následne je tento nástroj spustený a pokiaľ je pri tomto procese prítomný už spomínaný \enquote{Mantis argument}, nespustí sa hlavné okno aplikácie, ale len okno určené na odoslanie reportu. Po prečítaní obsahu je súbor samozrejme zmazaný, aby neovplyvnil ďalšie spustenie nástroja HoboThor.

Pokiaľ ide o odoslanie reportu zo vzdialeného PC ukázala sa ako problematická doba ukladania snímky obrazovky na disk. Kvôli tomuto problému musí aplikácia najskôr počkať na uloženie súboru a až následne vykonávať ďalšie inštrukcie. Toho som docielil jednoduchou slučkou, ktorá sa sama ukončí v prípade nájdenia požadovaného súboru alebo po pretečení určitého času. To slúži ako ochrana pred zacyklením. 

\vspace{10pt}
\begin{lstlisting}[label=src:Report,caption={Vytváranie lokálneho a vzdialeného záznamu o chybe}]
// Local report
if (HBTLink_Manager.sender_ServerIP == HBTLink_Manager.Instance.LocalIPAddress().ToString()) {
    string exefile = GameConfiguration.pathConfig.exeFile;
    if (File.Exists(exefile)) {
        var argFile = GameConfiguration.pathConfig.mantisArguments;

        if (File.Exists(argFile))
            File.Delete(argFile);

        File.WriteAllText(argFile, directoryReport.FullName);
        Application.OpenURL(exefile);
    }
}
// Remote report
else {
    float time = 0;
    while (time <= maxWaitTime) {
        yield return new WaitForSeconds(.1f);
        time++;
        if (File.Exists(screenFileName)) {
            screenSaved = true;
            yield break;
        }
    }
}
\end{lstlisting}

Na zmenu hodnoty premennej \textit{screenSaved} zareaguje metóda \textit{OnUpdate} z výpisu \ref{src:OnUpdate} a spustí metódu \textit{ZipAndSendToLinkManager}. Tá pomocou knižnice DotNetZip \cite{DotNetZip} prevedie celú zložku s reportom na zip súbor so zachovaním hierarchickej štruktúry podzložiek a súborov. Následne ho prevedie na reťazec s kódovaním base64 a predá triede HBTLink\_Manager na odoslanie do vzdialeného PC. Táto metóda je znázornená vo výpise \ref{src:Zip}. 

Rreťazec je následne pomocou TCP protokolu odoslaný na IP adresu určenú v konfiguračnom súbore alebo vybratú z prednastavených možností vo vývojárskej konzole počas hrania. Na vzdialenom PC musí byť spustený nástroj HoboThor a \enquote{počúvať} na určenom porte. Dáta sú po prijatí uložené do dočasnej zložky poskytovanej operačným systémom pomocou metódy \textit{Path.GetTempPath} v mennom priestore \textit{System.IO} a následne rozbalené. Cesta k tejto zložke je opäť zapísaná do \enquote{Mantis argumentu} a HoboThor je následne automaticky spustený znova. To vyústi k otvoreniu okna určeného na nahlasovanie chýb a načítaniu dát zo zložky s reportom.
\vspace{10pt}
\begin{lstlisting}[label=src:Zip,caption={Archivovanie zložky so zachovaním pôvodnej štruktúry}]
private void ZipAndSendToLinkManager() {
    string pathToZip = directoryReport.FullName + @"\report.zip";

    using (ZipFile zip = new ZipFile()) {
        var files = Directory.EnumerateFiles(directoryReport.FullName, "*.*", SearchOption.AllDirectories);
        foreach (string file in files) {
            if (file.Contains("Characters"))
                zip.AddFile(file, @"\Saves\Characters");
            else if (file.Contains("Worlds"))
                zip.AddFile(file, @"\Saves\Worlds");
            else
                zip.AddFile(file, "");
        }

        zip.Save(pathToZip);
        Debug.Log("Zipped to " + pathToZip);
    }

    if (File.Exists(pathToZip)) {
        string base64zip = System.Convert.ToBase64String(File.ReadAllBytes(pathToZip));
        HBTLink_Manager.Send_MantisReport(base64zip);
        File.Delete(pathToZip);
    }
}
\end{lstlisting}
\vspace{5pt}

Problém tohto postupu bol spočiatku vo veľkosti vyrovnávacej pamäte na strane prijímateľa, teda nástroja HoboThor, ktorá bola poddimenzovaná. Následné testovanie ukázalo, že spoľahlivá veľkosť tejto pamäte začína až na hodnote 2\textsuperscript{20} bytov v závislosti primárne od veľkosti odosielanej snímky obrazovky. Vytvorenie takejto veľkej vyrovnávacej pamäte a následné uloženie všetkých prijatých dát naraz ale nefungovalo na OS Linux. Testovacia aplikácia na tomto systéme zvládla prijať maximálne 14600 bytov. Táto hodnota odpovedá desaťnásobku MTU balíčku preneseného technológiou Ethernet v2 po odčítaní veľkostí TCP a IP hlavičiek. Veľkosť 1460 bytov sa zvykne nazývať aj MSS. Túto problematiku znázorňuje obrázok \ref{pic:Packet}.
\vspace{-50pt}
\begin{figure}[!htbp]
	\centering
	\includegraphics[width=1\textwidth]{Pictures/packet.png}
	\vspace{-60pt}
	\caption{Dátový balíček \cite{MSS}}
	\label{pic:Packet}
\end{figure}

Riešením bolo použitie vyrovnávacej pamäte o veľkosti 2\textsuperscript{10} bytov a postupné prijímanie dát zo sieťového prúdu pomocou cyklu. Gro tohto postupu je zobrazené vo výpise \ref{src:Stream}.
\vspace{10pt}
\begin{lstlisting}[label=src:Stream,caption={Postupné čítanie dát zo sieťového prúdu}]
TcpClient client = reciever_Listener.AcceptTcpClient();
NetworkStream nwStream = client.GetStream();

while ((i = nwStream.Read(buffer, 0, buffer.Length)) != 0)
{
    data += Encoding.ASCII.GetString(buffer, 0, i);
}
\end{lstlisting}
\vspace{5pt}

Mojou poslednou úlohou v časti reportovacieho systému na strane hry, ktorá prišla ako požiadavka od programátorov bolo pridať možnosť odosielať reporty priamo z editoru bez nutnosti mať spustenú hru. Typický prípad použitia bolo nahlasovanie chýb nájdených popri práci s náhľadom scény. Väčšina kódu bola prebratá z vyššie popísanej časti, museli byť však zmenené niektoré postupy. 

Odchytávanie klávesovej skratky bolo tentoraz realizované natívnym postupom zabudovaným do editora Unity. Stačilo vytvoriť statickú metódu \textit{CreateReport} a nad jej definíciu pridať atribút \enquote{MenuItem} ako znázorňuje výpis \ref{src:UnityReport}. To vyústi k vytvoreniu zástupcu tejto metódy v hornom paneli editora. Pozícia metódy v paneli je určená zadanou cestou v parametri atribútu \enquote{MenuItem}. Za túto cestou je potom možné pridať ľubovoľnú klávesovú skratku, ktorá túto akciu vyvolá.
\vspace{10pt}
\begin{lstlisting}[label=src:UnityReport,caption={Odchytenie stlačenia klávesovej skratky v rámci editora Unity}]
[MenuItem("Tools/HBT/Reporting/Create report #F11")] // # -> Shift
static void CreateReport()
{
    // body...
}
\end{lstlisting}
\vspace{5pt}

Pôvodný postup vytvorenia snímky obrazovky pomocou metódy \textit{CaptureScreenshotAsTexture} bolo nutné nahradiť metódou \textit{ReadScreenPixel}, ktorá ale potrebuje vedieť presnú lokáciu a rozmery okna. Získať tieto údaje sa mi nakoniec podarilo až volaním C++ metód z user32.dll. Počas testovania na 4K monitore sa ukázalo, že tento prístup nevhodne vyhodnocuje veľkosť okna s nastaveným škálovaním v OS Windows. Toto bolo nutné upraviť ručne, čo ukazuje výpis \ref{src:DLL}.
\vspace{10pt}
\begin{lstlisting}[label=src:DLL,caption={Získanie veľkosti okna spustenej aplikácie}]
[DllImport("user32.dll")]
private static extern bool GetWindowRect(IntPtr hwnd, ref Rect rectangle);
[DllImport("user32.dll")]
private static extern IntPtr GetActiveWindow();

private struct Rect {
    public int Left { get; set; }
    public int Top { get; set; }
    public int Right { get; set; }
    public int Bottom { get; set; }
}

private static Rect GetUnityBounds() {
    Rect unityWindowBounds = new Rect();
    float scale = Screen.dpi / 96;

    GetWindowRect(GetActiveWindow(), ref unityWindowBounds);

    unityWindowBounds.Right = (int)(unityWindowBounds.Right / scale);
    unityWindowBounds.Bottom = (int)(unityWindowBounds.Bottom / scale);
    
    return unityWindowBounds;
}
\end{lstlisting}

Na strane Windows Forms aplikácie implementovanej do nástroja HoboThor bolo nutné najskôr vytvoriť sadu tried a enumov, ktoré by po serializácií/deserializácií presne kopírovali štruktúru projektu či reportu s ktorou pracuje služba Mantis Bug Tracker. Následne bolo nutné navrhnúť užívateľské rozhranie. To prechádzalo iteratívnymi zmenami na základe spätnej väzby až do svojej finálnej podoby znázornenej na obrázku \ref{pic:Report}.

\begin{figure}[!htbp]
	\centering
	\setlength{\fboxsep}{0pt}
	\setlength{\fboxrule}{1pt}
	\fbox {
		\includegraphics[width=.98\textwidth]{Pictures/report.png}
	}
	\caption{Užívateľské rozhranie aplikácie Mantis Report}
	\label{pic:Report}
\end{figure}

Po spustení aplikácie sa načíta uložená snímka obrazovky a zobrazí sa v náhľadovom okne na pravej strane. Vzhľadom na to, že v dobe spúšťania tento obrázok ešte nemusí byť plne k dispozícií je táto funkcionalita realizované v separátnom vlákne pomocou tzv. \enquote{Background Workera}. Ten v cykle prehľadáva zložku s reportom kvôli prítomnosti obrázku a až následne, keď je k dispozícií ho zobrazí.

Po načítaní dát z report zložky do polí \enquote{Shrnutí} a \enquote{Popis} sú odoslané dve GET žiadosti na server. Prvá požaduje dáta o užívateľovi, ktorému náleží príslušný api kľúč odoslaný spolu so žiadosťou a druhá požaduje informácie o projekte. Medzi tieto informácie patria aj kategórie evidované pre daný projekt. Tie sú vložené do kombinovaného poľa \enquote{Kategorie}. Tento postup bol zvolený z dôvodu možných budúcich zmien v štruktúre kategórií na serveri. Ostatné kombinované polia boli vyplnené vopred pripravenými enumami. U nich sa žiadna budúca zmena nepredpokladá.

Užívateľ zadá dostupné informácie k nájdenej chybe a report odošle na server. Táto akcia zahŕňa získanie dát zo všetkých dostupných polí a následné vytvorenie inštancie triedy \textit{Issue}, ktorá tieto dáta zapúzdruje. Všetky prílohy určené na odoslanie sú potom uložené do príslušných polí bytov, prevedené na reťazce s kódovaním base64 obdobným postupom ako vo výpise \ref{src:Zip} a predané spomínanej inštancií.

V tomto momente bola aplikácia prakticky hotová ale z QA oddelenia prišla požiadavka na možnosť úpravy obrázka pred odoslaním bez nutnosti použitia externých nástrojov. Vytvoril som teda druhé okno pre túto aplikáciu, ktoré sa otvorí po kliknutí na náhľadový obrázok a umožňuje do neho kresliť. Toto okno je znázornené na obrázku \ref{pic:Paint}. 

\begin{figure}[!htbp]
	\centering
	\includegraphics[width=1\textwidth]{Pictures/pictureEditBox.png}
	\caption{Okno úpravy obrázka aplikácie Mantis Report}
	\label{pic:Paint}
\end{figure}

Postupne bola pridaná podpora viacerých hrúbok a farieb čiar či tlačítko reset, ktoré slúži na návrat k pôvodnému obrázku. Zmeny v tomto okne sú spätne reflektované aj náhľadovým obrázkom v hlavnom okne reportovacej aplikácie. 

Na kreslenie bolo využité vlastné riešenie založené na udalostiach \textit{MouseDown}, \textit{MouseUp} a \textit{MouseMove}. Pri pohybe myši spolu so stlačeným ľavým tlačidlom dôjde k vykresľovaníu čiary medzi dvoma bodmi, čo sa od určitej frekvencie zaznamenávania bodov javí ako súvislý ťah. Tento postup je demonštrovaný vo výpise \ref{src:Paint}.
\vspace{10pt}
\begin{lstlisting}[label=src:Paint,caption={Implementácia kreslenia v prostredí Windows Forms}]
private void pictureBoxBcg_MouseDown(object sender, MouseEventArgs e) {
    moving = true;
    x = e.X;
    y = e.Y;
}

private void pictureBoxBcg_MouseMove(object sender, MouseEventArgs e) {
    if (moving && x != -1 && y != -1) {
        g.DrawLine(pen, new Point(x, y), e.Location);
        x = e.X;
        y = e.Y;
        pictureBoxBcg.Invalidate();
    }
}
private void pictureBoxBcg_MouseUp(object sender, MouseEventArgs e) {
    moving = false;
    x = -1;
    y = -1;
}
\end{lstlisting}
\subsection{Vytváranie \enquote{Patch notes} pre QA oddelenie (GitLogger)}
\label{sec:GitLogger}
\textbf{Časová náročnosť:} \\ Nasadenie: 3 dni, následné úpravy: 1 deň.\\
\textbf{Úvod do problému:} \\ S blížiacim sa dátumom vydania hry sa zvyšuje aj frekvencia testovania a rýchlosť s akou pribúdajú opravy chýb. Medzi jednotlivými zostaveniami aplikácie býva nejaké časové obdobie - zvyčajne jeden týždeň. Toto obdobie je zakončené nahraním najnovšie zostavenej verzie hry na platformu Steam, kde ju môže QA oddelenie začať testovať. Informovanie testerov o najnovších zmenách a opravách môže byť pracné a náchylné na vynechanie niektorých dôležitých vecí. Mojou úlohou bolo tento proces pokiaľ možno čo najviac optimalizovať.\\
\textbf{Navrhované riešenia:} \\ Prvým navrhovaným riešením, ktoré sa už využívalo v niektorých vývojárskych nástrojoch bolo použitie knižnice, ktorá sa po zadaní správnych prihlasovacích údajov pripojí na Git server a prevedie prítomné \textit{commity} na štruktúru tried, s ktorou je potom možné ďalej pohodlne pracovať. Po preskúmaní tohto riešenia sa ukázalo, že jednotlivé knihovne nemajú vyriešenú podporu pripojenia na server pomocou protokolu SSH ale iba HTTPS, čo sa ukázalo ako veľký problém. Prišiel som teda s riešením, ktoré by si stiahlo \textit{commity} iba z lokálneho repozitára a to pomocou PowerShellu v OS Windows.  \\
\textbf{Realizácia:} \\ Po založení testovacieho projektu na platforme .NET bolo mojím prvým krokom zistiť, ako programovo spustiť rôzne skripty a príkazy v programe Windows PowerShell či klasickom príkazovom riadku. Postupne som narazil na triedu \textit{PowerShell} určenú presne pre tento prípad použitia. Pomocou tejto triedy som si vytvoril metódu, ktorá vie spustiť ľubovoľný príkaz a vrátiť jeho výsledok ako pole reťazcov. Táto metóda je znázornená vo výpise \ref{src:Shell}. 

Ako sa ukázalo, Windows PowerShell v predvolenom nastavení pre český jazyk nepoužíva kódovanie UTF-8, čo zapríčinilo nesprávnu interpretáciu znakov s diakritikou. Bolo nutné v nastaveniach systému v sekcií región túto voľbu ručne zapnúť, nakoľko je stále vo fáze vývoja.
\vspace{10pt}
\begin{lstlisting}[label=src:Shell,caption={Metóda vykonávajúca skript v programe Powershell}]
private string[] InvokePowershellScript(string gitCmd) {
    string[] results;
    using (PowerShell powershell = PowerShell.Create()) {
        powershell.AddScript($"cd {projectDirectory}");
        powershell.AddScript(gitCmd);

        results = powershell.Invoke().Select(r => r.ToString()).ToArray();
    }

    return results;
}
\end{lstlisting}

Po vyskúšaní rôznych preddefinovaných variant príkazu \textit{git log} som sa rozhodol zostaviť si vlastný príkaz, nakoľko mi žiadna preddefinovaná varianta úplne nevyhovovala. Hlavným dôvodom bola snaha čo najviac zjednodušiť následnú syntaktickú analýzu. Tento príkaz som sa rozhodol vytvárať dynamicky, aby sa sám aktualizoval po zmene premennej \textit{mainSplitter}. Ukážka tohto postupu je zobrazená vo výpise \ref{src:Log}.
\vspace{10pt}
\begin{lstlisting}[label=src:Log,caption={Dynamické vytváranie vlastného príkazu \textit{git log}}]
private const char mainSplitter = '&';
private string gitLog = "git log ";

public GitLogger() {
    gitLog += string.Format("--pretty=format:\"%an%{0}%ad%{0}%s\"" +
        " --date=format:'%d.%m.%Y'", ((int)mainSplitter).ToHex());
}
\end{lstlisting}

Následne bolo nutné v cykle prejsť všetky výsledky od najnovšieho \textit{commitu} až po \textit{commit}, ktorý značil posledné zostavenie hry interne dostupné na platforme Steam. Z týchto výsledkov sa odstránili všetky zlúčenia jednotlivých vetiev a ďalšie  \textit{commity}, ktoré neobsahovali ani opravy chýb ani novo pridané vylepšenia. Opravy boli značené tzv. \enquote{bugMarkerom} (@b) a vylepšenia tzv. \enquote{featureMarkerom} (@f). Tých mohlo byť v jednom \textit{commite} hneď niekoľko, preto bol na každý \textit{commit}, ktorý nejakú z týchto značiek obsahoval, aplikovaný regulárny výraz a jednotlivé časti boli ďalej spracovávané samostatne. Tento regulárny výraz zobrazuje výpis \ref{src:Regex}. Každá časť navyše mohla byť rozdelená na viacero menších častí rovnakého druhu pomocou znaku `;`. Jednotlivé elementárne časti boli následne štruktúrovane uložené do súboru.
\vspace{10pt}
\begin{lstlisting}[label=src:Regex,caption={Regulárny výraz určený na syntaktickú analýzu tela \textit{commitu}}]
var matches = Regex.Matches(body, string.Format("({0}|{1})[^@]*", bugMarker, featureMarker));
\end{lstlisting}

Pôvodný prípad použitia mal zahŕňať automatické otvorenie tohto súboru v predvolenom textovom editore a jeho ručné skopírovanie do programu Microsof Teams, ktorý sa používa na komunikáciu vo firme. Rozhodol som sa ale preskúmať možnosti automatizovaného odosielania správ v tejto službe a pokúsil sa implementovať lepšie riešenie.

Služba Microsoft Teams podporuje automatizované posielanie správ okrem iného aj pomocou tzv. \enquote{Webhooks}. Tie sa dajú nakonfigurovať priamo v užívateľskom rozhraní služby a to buď pre konkrétny kanál alebo konverzáciu. \enquote{Webhook} vygeneruje jedinečnú URL adresu, na ktorú je možné posielať POST žiadosti, ktoré sú spomenuté aj v sekcií \ref{sec:QACode}. Telo takejto žiadosti sa potom v aplikácií Microsoft Teams zobrazí ako správa odoslaná \enquote{Webhookom}. Dáta sú prenášané ako štruktúrovaný JSON reťazec. Okrem jednoduchých správ je možné posielať aj formátovaný text pomocou značkovacieho jazyka Markdown, prípadne tzv. karty. 

Pomocou nástroja Postman som vo formáte JSON vytvoril dva návrhy takejto karty a nechal kolegov rozhodnúť o tom, ktorý sa nakoniec použije. Podľa zvoleného návrhu som následne implementoval triedu \textit{Message} tak, aby svojou vnútornou štruktúrou odpovedala štruktúre danej karty a bolo možné ju použiť na serializáciu či deserializáciu. 

Základnú kostru karty, ktorá sa počas vykonávania programu nebude meniť, som uložil do súboru. Pri každej novej POST žiadosti je tento súbor prečítaný a jeho obsah deserializovaný na novú inštanciu triedy \textit{Message}. Do tela správy sú vložené dáta získané z \textit{commitov} po syntaktickej analýze a následne je celá správa odoslaná do \enquote{Webhooku} metódu uvedenou vo výpise \ref{src:Shell}. Tento postup demonštruje výpis \ref{src:Message}. 
\vspace{10pt}
\begin{lstlisting}[label=src:Message,caption={Vytvorenie a odoslanie správy do služby Microsoft Teams}, escapechar={|}]
Message message = Message.FromJson(File.ReadAllText(pathToJSON));
Content content = message.Attachments[0].|\color{words}Content|;

content.Title = header;
content.Sections[0].ActivityText = PrintListToJsonString(features);
content.Sections[1].ActivityText = PrintListToJsonString(bugs);

// cmdBegin == "Invoke-RestMethod -Method post -ContentType 'Application/Json; charset=UTF-8' -Body '";
string command = cmdBegin + Serialize.ToJson(message) + "' -Uri " + webHook;
string result = InvokePowershellScript(command)[0];
\end{lstlisting}

Metóda \textit{PrintListToJsonString} použitá vo výpise  \ref{src:Message} pridá do dát značky jazyka Markdown, čím sa ešte upraví finálny vzhľad. Zároveň pomocou regulárneho výrazu \mbox{``\#\\d+``} nahradí všetky výskyty číselných reťazcov začínajúcich znakom `\#` za klikateľný odkaz na stránku konkrétneho reportu v službe Mantis Bug Tracker. To je užitočné v prípadoch keď \textit{commit} priamo opravuje nejakú nahlásenú chybu. Vytvorená karta je znázornená na obrázku \ref{pic:Logger}.

\begin{figure}[!htbp]
	\centering
	\includegraphics[width=1\textwidth]{Pictures/gitlogger.png}
	\caption{Vytvorená karta v aplikácií Microsoft Teams}
	\label{pic:Logger}
\end{figure}

Poslednou pridanou funkcionalitou bolo, aby sa táto karta neposielala pri každom zostavení hry na serveri ale iba vtedy, keď je to skutočne žiadúce. Aplikácia teda prečíta obsah súboru BuildSettings.asset a ak v ňom nájde reťazec ``sendPatchNotesToTeams: 1`` vykoná odoslanie. V opačnom prípade sú dáta len štruktúrovane zapísané na disk. Súbor BuildSettings.asset je podrobne popísaný v sekcií \ref{sec:BuildServer}.

Aplikácia bola nasadená ako externý súbor, ktorý je spustený službou Gitlab CI/CD bližšie popísanou v sekcií \ref{sec:GitLab}.
\subsection{Automatizované zostavenie hry na serveri (Build Server)}
\label{sec:BuildServer}
\textbf{Časová náročnosť:} \\ Nasadenie: 6 dní, následné úpravy podľa požiadaviek: 2 dni.\\
\textbf{Úvod do problému:} \\ Zostavenie projektu Hobo: Tough Life môže v závislosti od rôznych faktorov trvať aj viac ako hodinu čistého času. Počas tejto doby samozrejme nie je možné do projektu zasahovať, čo do značnej miery obmedzuje možnosť ďalej vyvíjať. Zostavenie navyše často končí neúspechom a je nutné po vykonaní opráv proces opakovať. Mojou úlohou bolo teda preskúmať rôzne možnosti ako toto zostavenie vykonať automaticky a bez zablokovania pracovnej stanice. \\
\textbf{Navrhované riešenia:} \\ Prvou možnosťou, ktorá sa však hneď zavrhla bolo použitie riešenia priamo od firmy Unity Technologies a síce ich ponúkaného \enquote{Unity Cloud Buildu}. Táto možnost je dostupná za určitý poplatok závislý od veľkosti repozitára. Tá je v našom prípade značná, čo by toto riešenie predražilo a zároveň by nahrávanie repozitára mimo lokálnu sieť bolo časovo náročné. Po preskúmaní rôznych riešení použiteľných na lokálnom serveri sa finálny výber zúžil na služby Jenkins, TeamCity a Gitlab \mbox{CI/CD}. Voľba nakoniec padla na Gitlab CI/CD nakoľko na firemnom serveri je využívaná služba Gitlab a očakávala sa teda najlepšia kompatibilita spomedzi ponúkaných možností.\\
\textbf{Realizácia:} \\ Kvôli už spomínanému rozsahu hry nie je vhodné testovať automatizované zostavenie priamo na nej, bolo teda nutné vytvoriť testovací projekt. Zostavenie tohto projektu na pracovnej stanici pomocou metódy \textit{BuildPipeline.BuildPlayer} prebehlo úspešne. Táto metóda prijíma niekoľko nastavení ako napríklad cieľová platforma, scény určené na zostavenie či cestu k zostavenému spustiteľnému súboru a následne sama toto zostavenie vykoná. Kľúčom bolo teda túto metódu spolu s nejakou ďalšou logikou zavolať v rámci reakcie na nejakú udalosť, ktorá nastane na serveri. Táto udalosť môže byť napríklad zlúčenie zmien v rôznych vetvách či nahranie najnovších zmien v kóde do určitej vetvy vo vzdialenom repozitári. Druhú spomínanú variantu sme sa rozhodli využiť a teda spustiť zostavenie po vykonaní príkazu \textit{push} do vetvy master, ktorá je hlavnou vetvou vo verzovacom systéme.

Po úspešnom zostavení projektu na pracovnej stanici pomocou skriptu bolo teda ďalším krokom nasadenie na server. K nasadeniu bolo nutné vytvoriť konfiguračný súbor .gitlab-ci.yml, v ktorom sú uložené príkazy, ktoré majú byť vykonané ako reakcia na konkrétnu udalosť. Tieto príkazy sú organizované do etáp. Každá etapa sa potom stará o určitú sadu úloh, ktoré spolu súvisia. Príkladom by mohli byť etapy ako otestuj, zostav či nasaď. Na prvý pohľad je jasné, čo bude mať daná etapa na starosť. 

V našom prípade bola nutná iba etapa \enquote{build}, je ale možné, že do budúcna sa tento počet bude zvyšovať. Obsah súboru .gitlab-ci.yml, ktorý bol použitý v projekte je možné vidieť vo výpise \ref{src:YML}. V tomto súbore môže byť nakonfigurovaná aj pomerne zložitá logika, nakoniec sa však z rôznych dôvodov osvedčilo túto logiku presunúť do separátneho batch súboru a ten len z .gitlab-ci.yml spustiť. Jedným z týchto dôvodov bolo napríklad, že po neúspešnom zostavení hry sa etapa \enquote{build} ukončila úspešne, čo je pomerne zásadný problém, ktorý sa mi nepodarilo vyriešiť. Naopak použitie batch súboru umožnilo jednoducho ukončiť etapu s hodnotou navrátenou enginu Unity. Typicky išlo o kompilačné chyby. Tento postup sa osvedčil aj v prípade chýb prejavených počas zostavovania projektu. V tomto prípade bolo možné nepriamo použiť hodnotu \textit{result} zo štruktúry \textit{BuildReport.summary}, ktorú vracia metóda \textit{BuildPipeline.BuildPlayer}. 

Príkazy zadané v súbore .gitlab-ci.yml vykonáva tzv \enquote{Gitlab runner}. Ten je možné stiahnuť z oficiálnych stránok ako spustiteľný súbor a pre zabezpečenie správneho fungovania ho spúšťať po štarte systému. Najskôr je však nutné ho zaregistrovať na konkrétny projekt alebo niekoľko projektov. Registrácia prebieha v niekoľkých jednoduchých krokoch po spustení programu \enquote{Gitlab runner} z príkazového riadku spolu s príkazom \textit{register}. Jeden z krokov vyžaduje od užívateľa tzv. token, ten je možné nájsť v nastaveniach repozitára vo webovej aplikácií Gitlab. Posledným krokom je potom zvolenie tzv. \enquote{executora}, pomocou ktorého bude  \enquote{Gitlab runner} vykonávať zadané príkazy. V našom prípade bola zvolená možnosť \textit{shell}, čo značí prosté vykonávanie príkazov v príkazovom riadku lokálneho PC.

\vspace{10pt}
\begin{lstlisting}[language=yml,label=src:YML,caption={Obsah súboru .gitlab-ci.yml}]
variables:
  GIT_CLONE_PATH: $CI_BUILDS_DIR\
  GIT_CLEAN_FLAGS: none

unity-build: 
  stage: build
  only:
    - master
  script:
    - C:\PerunCreative\Projekty\Hobo\Build\runBuild.bat
  tags: 
    - unity
\end{lstlisting}

Registrácia neprebehla úspešne z dôvodu, že server, na ktorom je uložený náš projekt nemá doménu a ani základný SSL certifikát. Ten sa nakoniec podarilo vytvoriť a vlastným podpisom pomocou nástroja OpenSSL. Výsledný certifikát potom musel byť uložený aj na strane servera aj na strane \enquote{Gitlab runnera} aby sa  zabezpečila úspešná registrácia.

Ďalším problémom bola prednastavená \textit{clone/fetch} zložka, do ktorej si \enquote{Gitlab runner} sťahuje najnovšie zmeny na projekte pred zahájením zostavovania. Pri veľkosti nášho repozitára, ktorej hodnota presahuje 100GB by bolo zdĺhavé a nehospodárne mať na serveri dve takéto separátne zložky. Problém by nastal aj pri manuálnych zásahoch do repozitára, ktoré by v réžií samotného Gitlabu boli veľmi zdĺhavé, a tak by sa museli vykonávať ručne na dvoch miestach. Gitlab CI/CD neumožňuje zadanie ľubovolnej cesty do premennej \textit{GIT\_CLONE\_PATH} v súbore .gitlab-ci.yml. Tá sa musí vždy odvíjať od nastavenia \textit{CI\_BUILD\_DIR}. Hodnotu tejto premennej sa napokon po niekoľkých neúspešných pokusoch podarilo nastaviť priamo v konfiguračnom súbore \enquote{Gitlab Runnera}.

Ďalším krokom bolo vytvorenie samotného batch súboru, ktorý bude spúštaný z .gitlab-ci.yml a ktorý bude zároveň spúštať engine za účelom zostavenia projektu. Z toho vyplýva nutnosť mať vždy k dispozícií cestu k editoru Unity. Ten je ale často aktualizovaný a cesta je teda závislá od jeho aktuálnej verzie. Za týmto účelom bol použitý textový súbor ProjectVersion.txt, ktorý obsahuje informácie o aktuálnej verzií projektu. Pokiaľ sa verzia projektu a editoru nebude zhodovať vyústi to do chyby, kvôli neplatnej ceste čo slúži ako impulz k aktualizovaniu editoru na serveri.

Engine Unity ponúka širokú škálu parametrov s ktorými môže byť spustený. Okrem cesty k projektu a cesty k logovaciemu súboru boli použité parametre ako \textit{batchmode}, ktorý spustí program bez užívateľského rozhrania a parameter \textit{quit}, ktorý editor ukončí po vykonaní všetkých naprogramovaných akcií. Nakoniec je ešte nutné uviesť statickú metódu, ktorá má byť zavolaná. Identifikátor tejto metódy musí byť uvedený vrátane všetkých menných priestorov, do ktorých metóda náleží. Návratová hodnota z editoru je následne uložená do premennej \textit{ERRORLEVEL}. Podľa tejto premennej je ukončené vykonávanie batch súboru a zároveň podľa nej .gitlab-ci.yml nastaví výsledok etapy. Po úspešnom zostavení je ešte spustený súbor GitLogger.exe, ktorého účel bol podrobne vysvetlený v sekcií \ref{sec:GitLogger}. Obsah celého batch súboru potom znázorňuje výpis \ref{src:batch}.

\vspace{5pt}
\begin{lstlisting}[style=Batch,label=src:batch,caption={Skript zabezpečujúci zostavenie hry na serveri}]
@ECHO off
SET project_path="C:\PerunCreative\Projekty\Hobo\HoboTL"
SET path_to_log="C:\PerunCreative\Projekty\Hobo\Build\build.log"

SET /p var=<%project_path%\ProjectSettings\ProjectVersion.txt
SET version=%var:~17%
ECHO Project version is: %version%

C:\"Program Files"\Unity\Hub\Editor\%version%\Editor\Unity.exe -quit -batchmode -logfile %path_to_log% -projectPath %project_path% -executeMethod Dev.Build.BuildScript.Build

IF %ERRORLEVEL% GTR 0 (
	ECHO An error with errorlevel %ERRORLEVEL% occurs
	ECHO Check logfile build.txt in project folder for more details
) ELSE (
	ECHO Build succeeded
	START "" "GitLogger.exe"
)

EXIT %errorlevel%
\end{lstlisting}

Metóda \textit{BuildScript.Build} volá metódu \textit{BuildScript.InternalBuild} s parametrom \textit{closeAfterBuild} nastaveným na hodnotu \textit{true}. Toto riešenie bolo zvolené z dôvodu, aby sa pri manuálnom spustení zostavovania pomocou skriptu, napríklad z horného menu editora Unity, editor neukončil. Úloha metódy \textit{InternalBuild} je potom nájsť a načítať dáta z tzv. \enquote{Scriptable Objectu}, čo je uvedené vo výpise \ref{src:asset}, a následne tieto dáta predať metóde \textit{SetUpPlatforms}. Návratová hodnota tejto metódy je potom použítá ako návratová hodnota celého programu.

\vspace{10pt}
\begin{lstlisting}[label=src:asset,caption={Načítanie dát zo skriptovateľného objektu}]
buildSettings = AssetDatabase.LoadAssetAtPath<BuildSettings>("Assets/Settings/BuildSettings.asset");
\end{lstlisting}

\enquote{Scriptable Object} BuildSettings.asset slúži ako dátové úložisko všetkých nastavení týkajúcich sa automatizovaného zostavenia. S týmto objektom je potom možné pohodlne pracovať priamo z užívateľského rozhrania enginu nakoľko som implementoval tzv \enquote{Custom editor}. Ten je znázotnený na obrázku \ref{pic:Custom}.

\begin{figure}[!htbp]
	\centering
	\includegraphics[width=.90\textwidth]{Pictures/buildDetail.png}
	\caption{Vlastné okno editora pre manipuláciu s objektom BuildSettings}
	\label{pic:Custom}
\end{figure}

Samotná trieda \textit{BuildSettings} dedí z triedy \textit{ScriptableObject} a je iba súhrnom relatívne veľkého množstva serializovaných premenných a enumov. \enquote{Custom editor} je potom realizovaný ako trieda \textit{BuildSettingsEditor}, ktorá je potomkom triedy \textit{Editor}. Táto trieda sa nachádza v preddefinovanej \textit{Assembly-CSharp-Editor}, preto je nutné potomkov triedy \textit{Editor} presunúť do zložky Editor alebo ich kód obaliť do direktívy UNITY\_EDITOR zobrazenej aj vo výpise \ref{src:Pragma}. To zabráni vyvolaniu chyby pri pokuse o zostavenie projektu nakoľko \textit{Assembly-CSharp-Editor} z pochopiteľných dôvodov nie je prítomná v zostavenej verzií hry. Základná kostra triedy \textit{BuildSettings}, ktorá vykreslí iba premennú \textit{platforms} je zobrazená vo výpise \ref{src:bseditor}.

\vspace{10pt}
\begin{lstlisting}[label=src:bseditor,caption={Kostra triedy určenej pre vykreslenie vlastného okna v editore Unity}]
[CustomEditor(typeof(BuildSettings))]
public class BuildSettingsEditor : Editor {
    private BuildSettings settings;
    private SerializedProperty platforms;
    
    private void OnEnable() {
        platforms = serializedObject.FindProperty("platforms");
    }
    public override void OnInspectorGUI() {
        settings = AssetDatabase.LoadAssetAtPath<BuildSettings>("Assets/Settings/BuildSettings.asset");
        
        EditorGUILayout.PropertyField(platforms);
        serializedObject.ApplyModifiedProperties();
    }
}
\end{lstlisting}

Finálna trieda, použitá v projekte bola okrem pridania ostatných premenných doplnená o nadpisy, medzery medzi skupinami a v neposlednej rade aj o varovné hlásenia pri nastavení polí \textit{Platform} či \textit{Scenes} na hodnotu \textit{Nothing}. Varovné hlásenie sa objaví aj pri nastavení tzv. \enquote{scripting backendu} na hodnotu inú ako IL2CPP, čo je dôležité nastavenie z hľadiska výkonu finálneho produktu. Pri tomto nastavení je IL kód pred vytvorením spustiteľného súboru prevedený na kód jazyka \mbox{C++ \cite{IL2CPP}}. Ukážka takéhoto varovania je uvedená na obrázku \ref{pic:Warr}.

\begin{figure}[!htbp]
	\centering
	\includegraphics[width=1\textwidth]{Pictures/warr.png}
	\caption{Varovanie v okne editora}
	\label{pic:Warr}
\end{figure}

Metóda \textit{SetUpPlatforms} spomenutá vyššie zo získaných dát od metódy \textit{InternalBuild} extrahuje tzv. masky. Maska platformy určuje, na ktoré platformy sa bude hra zostavovať a maska scény, ktoré scény budú v zostavenom súbore prítomné. Princíp použitia takejto masky je demonštrovaný na získavaní scén zvolených v objekte BuildSettings.asset vo výpise \ref{src:scenes}. Tieto scény sú potom predávané ako argument príslušným zostavovacím metódam. 

\vspace{10pt}
\begin{lstlisting}[label=src:scenes,caption={Extrahovanie zvolených scén pomocou masky}]
private static string[] SetUpScenes() {
    Array enumScenes = Enum.GetValues(typeof(BuildSettings.Scene));
    List<string> scenesToBuild = new List<string>();

    foreach (var item in enumScenes) {
        if (IsSelected(sceneMask, (BuildSettings.Scene)item)) {
            scenesToBuild.Add("Assets/Scenes/" + item + ".unity");
        }
    }

    return scenesToBuild.ToArray();
}

private static bool IsSelected(int EnumMask, Enum enumValue) {
    int tempMask = 1 << Convert.ToInt32(enumValue);
    
    return (EnumMask & tempMask) == 0 ? false : true;
}
\end{lstlisting}

Obdobne prebieha aj práca s maskou platformy. Ak metóda \textit{IsSelected} vráti hodnotu \textit{true} pri dotazovaní na konkrétnu platformu, je spustená príslušná zostavovacia metóda. Tá vykoná samotné zostavenie pomocou metódy \textit{BuildPipeline.BuildPlayer} s nastaveniami špecifickými pre danú platformu. Návratová hodnota sa potom vráti späť metóde \textit{SetUpPlatforms} a pokiaľ neznačí úspech je vyhodená výnimka s popisom, že zostavenie na danej platforme zlyhalo. Ak všetky zvolené zostavenia skončia úspechom, je úspešne ukončený aj celý program. Gro  metódy na zostavenie hry pre OS Windows je znázornený vo výpise \ref{src:bwin}. 

Ako je možné vidieť, metóda \textit{BuildWindows} dostane ako prvý argument nastavenia špecifické pre danú platformu, v tomto prípade je to platforma Windows. Tieto nastavenia momentálne obsahujú iba cestu k zložke do ktorej má byť zostavenie pre danú platformu uložené. Toto riešenie bolo dočasne zvolené z dôvodu, že nie je možné predikovať špecifiká, ktoré si zostavenie na niektoré konzolové platformy bude vyžadovať. Keď budú tieto informácie dostupné plánuje sa zjednotenie všetkých zostavovacích metód do jednej. Táto metóda potom bude ako prvý argument prijímať generalizáciu nejakých konkrétnych nastavení a bude riadená dátami získanými z týchto nastavení.

\vspace{10pt}
\begin{lstlisting}[label=src:bwin,caption={Nastavenie a spustenie programového zostavenia hry pre OS Windows}]
private static bool BuildWindows(WindowsSettings settings, string[] scenes) {

	// ...
	
    BuildPlayerOptions options = new BuildPlayerOptions();
    options.scenes = scenes;
    options.locationPathName = path + Application.productName + ".exe";
    options.targetGroup = BuildTargetGroup.Standalone;
    options.target = BuildTarget.StandaloneWindows64;
    options.options = GetBuildOptions(); // Development, AllowDebugging, ...

    BuildReport report = BuildPipeline.BuildPlayer(options);
    
    return report.summary.result == BuildResult.Succeeded ? true : false;
}
\end{lstlisting}

Postupne boli do projektu pridané aj ďalšie možnosti zostavenia. Možnosť \enquote{scriptsOnly} značí, že budú nanovo prekompilované všetky skripty bez nutnosti zostaviť celý projekt nanovo. Táto možnosť ale nie je k dispozícií pre \enquote{scripting backend} IL2CPP, takže je určená len na vývojárske využitie, kde je nutné robiť veľa iteratívnych zmien v krátkom čase a hneď ich aj testovať. Druhou implementovanou možnosťou bolo v už zostavenom projekte aktualizovať len tzv. \enquote{bundles}. \enquote{Bundles} sú binárne súbory, ktoré môžu obsahovať napríklad nové textúry, modely či konverzácie a načítavajú sa dynamicky počas vykonávania programu \cite{Bundles}. Tieto možnosti teda pridávaju ďalšiu vrstvu optimalizácie tým, že kompletné zostavenie nastane až keď je to nevyhnutné.

\section{Optimalizácia a prevod hry na ďalšie platformy}
\label{sec:Port}
\subsection{Optimalizácia a refaktorovanie kódu}
\label{sec:optim}
\textbf{Časová náročnosť:} \\ 4 dni.\\
\textbf{Úvod do problému:} \\ S rastúcim výkonom výpočtovej techniky sa neustále znižuje dôraz na optimalizáciu a efektivitu. Herný vývoj je ale jedna z disciplín, v ktorých hrá optimalizácia veľmi dôležitú úlohu aj dnes. Rovnako ako narastá výkon tak narastajú aj požiadavky hráčov na vyššiu fotorealistickosť grafiky či viac vykreslených snímkov za sekundu. S tým ide ruku v ruke aj vývoj v ďalších oblastiach hardvéru ako sú napríklad monitory. Najmodernejšie sériovo vyrábané svojimi parametrami presahujú rozlíšenie 4k a obnovovaciu frekvenciu 240Hz. Na dosiahnutie hodnoty 60 snímok za sekundu je potom nutné vykonať všetky potrebné algoritmy v rámci 16 milisekúnd, čo nie je vždy jednoduché. Mojou úlohou bolo teda identifikovať potenciálne úzke hrdlá a pokiaľ možno ich aj optimalizovať \\
\textbf{Navrhované riešenia:} \\ Ako som už spomínal v sekcií \ref{sec:QACode} hra Hobo: Tough Life je postavená na hierarchickej štruktúre manažérov. Hlavný manažér obsahuje metódu \textit{Update} a v nej sú postupne volané metódy \textit{OnUpdate} všetkých ostatných manažérov. Z pohľadu výkonu je toto najkritickejšie miesto nakoľko metóda \textit{Update} je vykonávaná počas vykreslenia každej jednej snímky. Prvou vecou, na ktorú bolo nutné sa zamerať bola práve táto hierarchická štruktúra. Druhým návrhom bolo použiť nástroj Unity Profiler, ktorého účelom je zaznamenávať rôzne údaje o výkone hry do jednotlivých grafov. Takto je napríklad možné zobraziť aj presnú metódu, ktorá bola volaná v momente, keď nastal pád snímok. Treťou a poslednou vecou, na ktorú som sa rozhodol zamerať bola celková mikrooptimalizácia založená na vyhľadávaní a oprave drobných neoptimalizovaných častí kódu pochádzajúcich prevažne z ranného štádia vývoja.  \\
\textbf{Realizácia:} \\ Prvým krokom bolo teda preskúmanie štruktúry metód volaných pri vykresľovaní každej snímky. Veľký prepad snímok na konkrétnom mieste, napríklad pri komunikácií s nejakým NPC je problém,  pokiaľ však takáto situácia nastáva len veľmi zriedka, je výhodnejšie snažiť sa skôr o optimalizáciou často volaných metód. Tým sa zdvihne priemerná hodnota snímok za sekundu a už rozdiel v ráde nižších jednotiek býva v niektorých kritických bodoch hry signifikantný. V často volaných metódach, ako napríklad už spomenutá metóda \textit{Update}, by sa prakticky nemalo vyskytovať vytváranie nových premenných referenčného typu. Tieto premenné odkazujú na pamäťový priestor vytvorený na halde a spravidla zaberajú rádovo viac pamäte ako bežné, napríklad celočíselné premenné. Táto pamäť alokovaná na halde musí byť následne uvoľnená. Narozdiel od jazykov ako C++, v jazyku C\# sa o toto uvoľňovanie pamäte stará tzv \enquote{Garbage Collector}. Ten je volaný v pravidelných intervaloch, ale je možné ho zavolať aj predčasne, napríklad v momente načítavania novej lokácie, keď prudký pád snímok za sekundu nebude hrať žiadnu rolu. Z toho teda vyplýva, že čím menej pamäte bude nutné týmto spôsobom uvoľňovať, tým menší dopad na výkon a prepady snímok bude \enquote{Garbage Collector} mať. Alokácia novej pamäte by teda mala nastávať pri inicializácií a v niektorých ďalších situáciach, ale rozhodne nie pri vykresľovaní každej snímky. Aby sa ešte zmenšila nutnosť alokovania novej pamäte, je v projekte použitý aj tzv \enquote{Object Pool}. Ten slúži na recykláciu určitých objektov, aby ich nebolo nutné znova vytvárať. 

Ďalšou vecou, ktorá by sa mala nachádzať v takýchto metódach čo najmenej sú pochopiteľne cykly. Nie vždy sa im dá vyhnúť, je však vhodné zvážiť použitie iného spôsobu, napríklad korutiny. Týmto spôsobom by sa počet vykonávaní nejakého cyklu mohol zredukovať napríklad na štvrtinu, čo by vytvorilo možnosť niektoré akcie striedať medzi sebou.

Po podrobnom preskúmaní týchto metód, som nenašiel žiadne závažné úzke hrdlo. Toto zistenie nebolo až tak prekvapivé, nakoľko hra prešla počas svojho vývoja niekoľkými optimalizačnými cyklami s dôrazom práve na tieto miesta. Rovnako som bola aj dopredu upozornený, že problém optimalizácie je do veľkej miery hľadanie tzv. \enquote{ihly v kope sena}.

Druhou optimalizačnou stratégiou bolo použitie nástroja Unity Profiler. Tento nástroj pracuje v dvoch režimoch - štandardnom a hlbokom. Štandardný režim menej ovplyvňuje finálny výkon hry, v praxi sa mi ale veľmi neosvedčil. Umožňoval síce základnú detekciu problémov, od určitej hĺbky zanorenia ale nie je možné dohľadať konkrétne volané metódy. Užitočnosť tohto režimu sa ale ukázala pri hľadaní alokovanej pamäte v danom snímku. Hodnoty namerané v potenciálne problematickom mieste a síce pri otváraní inventára znázorňuje obázok \ref{pic:Prof}.

\begin{figure}[!htbp]
	\centering
	\includegraphics[width=1\textwidth]{Pictures/profiler.png}
	\caption{Hodnoty namerané nástrojom Unity Profiler}
	\label{pic:Prof}
\end{figure}

Po otvorení inventára dôjde k vytvoreniu veľkého množstva objektov, ktoré sa týkajú uživateľského rozhrania. Najväčšiu časť z alokovaných objektov tvorili užívateľom získané predmety. Po porade s kolegami sme dospeli k záveru, že by to bolo možné optimalizovať len nejakou formou stránkovania, čo by ale znamenalo nutnosť prepracovať celý doterajší systém, a to sa ukázalo z časového hľadiska nerealizovateľné. Čo sa ostatných prvkov užívateľského rozhrania inventára týka, žiadny svojou náročnosťou výrazne neprevyšoval ostatné, takže sa upustilo od ďalšieho skúmania. Veľká alokácia pamäte bola ešte samozrejme prítomná pri štarte hry. To sa nám podarilo z velkej miery optimalizovať.

Následné využívanie hlbokého režimu profilera ukazovalo niekoľko potenciálnych problematických miest, všetky sa ale ukázali ako slepé uličky. Niektoré boli spôsobené spustením hry v rámci editoru a v samostatnej zostavenej verzií ich nebolo možné zreprodukovať, iné boli nevyhnutné pre samotný chod hry, prípadne zabezpečovali vykresľovanie grafiky samotnej.

Následné mikrooptimalizácie boli zamerané tzv \enquote{cachovanie premenných}, prevod \textit{foreach} cyklov na klasické \textit{for} cykly, prednastavenie kapacity rôznych dátových štruktúr pri ich vytváraní, používanie lokálneho súradnicového systému na úkor globálneho pokiaľ to bolo možné či zabránenie zbytočnej serializácií premenných, ktoré nutne serializované byť nemuseli.

\enquote{Cachovanie premenných} je jednoduchá technika pri ktorej sa ukladajú získané dáta do nejakej dočasnej premennej aby sa s nimi mohlo ďalej pracovať bez nutnosti neustále sa na ne dotazovať znova. Efektivita takéhoto prístupu sa naviac ukazuje v spojení s \textit{for} cyklom. Namiesto toho, aby sa kód každú iteráciu cyklu vždy dotazoval na dĺžku nejakej dátovej štruktúry je táto dĺžka uložená do premennej a vždy len prečítaná.

\textit{Foreach} cyklus bol v priebehu vývoja postupne nahrádzaný \textit{for} cyklom. Dôvodom bolo, že cyklus \textit{for} vykazuje prakticky vždy lepšie výsledky z hľadiska výkonu. Vo väčšine kľúčových miest bol nahradený už v dobe keď som začínal s projektom pracovať, niekoľko desiatok takých, kde ho bolo potrebné nahradiť sa ale našlo. Išlo o prípady, kde sa tento cyklus používa v rámci čistej hry pre jedného hráča. Zasahovať do cyklov v rámci vývojárskych nástrojov by z hľadiska výkonu nijak nepomohlo a nezasahovalo sa z tohto pohľadu ani do zložky hry pre viac hráčov.

Prednastavenie kapacity dátových štruktúr je taktiež veľmi užitočná optimalizácia. Obyčajné pole, ktoré je na projekte preferované, pokiaľ ho je možné použiť, sa vytvára s kapacitou takou, aby dokázalo bezpečne uložiť všetky dáta. Dátové štruktúry ako \textit{List} či \textit{Dictionary} majú naproti tomu výhodu, že môžu svoju kapacitu postupne zväčšovať. Časté zväčšovanie je ale veľmi náročné z hľadiska výpočtového výkonu nakoľko je nutné po presiahnutí pôvodnej kapacity vytvoriť na pozadí novú dátovú štruktúru s väčšou kapacitou a jednotlivé prvky do nej skopírovať. Pokiaľ teda programátor má aspoň približnú predstavu o počte budúcich uložených prvkov je vhodné tomu priblížiť aj prednastavenú kapacitu. V niektorých prípadoch som skutočne našiel takéto prípady a následne ich opravil.

Posledné dve vykonávané mikrooptimalizácie úzko súvisia s enginom Unity. Prvá z nich je uprednostnenie lokálneho súradnicového systému oproti globálnemu. To je z dôvodu, že lokálny súradnicový systém je relatívny k rodičovskému objektu a globálne koordináty sa musia vždy vyrátať zo všetkých rodičovských objektov až ku koreňovému objektu, čo značí omnoho vyššiu náročnosť na výpočtový výkon. Čo sa serializácie objektov týka, Unity engine automaticky serializuje všetky verejné premenné objektu. Pokiaľ nie je nutné tieto premenné serializovať nemali by byť označené ako verejné. Tento prístup je zlý aj z hľadiska zapúzdrenia. V projekte sa od ranného vývoja vyskytovali niektoré čisto verejné triedy, mojou úlohou bolo teda skontrolovať, čo je potrebné serializovať a čo nie. Následne bolo nutné upraviť modifikátor prístupu podľa potreby a prakticky všetky verejné premenné nahradiť za tzv \enquote{Properties}. Pri tomto postupe bolo nutné dbať na serializované dáta. Niektoré z týchto dát boli nastavované a následne ladené podľa potreby priamo v editore a strata týchto dát by predstavovala veľký problém. Dáta sa aj automaticky zmažu po premenovaní danej premennej a následnej kompilácií. 

Po jednom nechcenom premenovaní bolo nutné ručne obnovovať niektoré dôležité dáta ako napríklad identifikátory objektov, našťastie sa to stalo iba pri jednej dátovej štruktúre, ktorá nebola veľmi obsiahla. Problémy nastali aj pri niektorých nevhodne \enquote{zacachovaných} premenných, prípadne pri prevode cyklov. Po ich následnej úprave a prekontrolovaní všetkých zmien Fbola optimalizácia a refaktorovanie ukončené z dôvodu nenájdenia ďalších veľkých problémov a nutnosti venovať sa ďalším projektom. Predtým ale ešte došlo k aplikácií automatizovaných nástrojov na formátovanie kódu či vymazanie nevyužívaných \textit{using} príkazov.

\subsection{Prevod hry na OS Linux}
\label{sec:linux}
\textbf{Časová náročnosť:} \\ 6 dní.\\
\textbf{Úvod do problému:} \\ Hra Hobo: Tough Life vychádza primárne na platforme Steam. Steam bol dlhodobo synonymom pre hranie na OS Windows, dnes ale podporuje aj ďalšie operačné systémy ako Linux či MacOS. Podpora zo strany distribútora je však iba jedna časť. O samotný prevod hry sa však musí  postarať vývojár či externé štúdio. Podpora však musí byť zaistená aj zo strany enginu, na ktorom je hra vytvorená. Engine Unity umožňuje pomerne jednoduchý prevod hry na iné platformy po doinštalovaní príslušného modulu a zvolení správnych nastavení zostavenia. Sú však veci, ktoré sa chovajú rozdielne na rôznych platformách a mojou úlohou teda bolo tieto veci nájsť, nahlásiť a prípadne aj opraviť. V dobe písania tohto textu sa jednalo iba o prevod na OS Linux, po ostrom vydaní sa však plánujú aj vydania na konzolové platformy.\\
\textbf{Realizácia:} \\ Testovanie, prípadne oprava chýb, ktoré sa vyskytli v hre spustenej na OS Linux by sa realizovalo len veľmi zle bez prístupu k PC s týmto OS. Narozdiel od OS Windows poskytuje Linux veľké množstvo distribúcií s rôznou úrovňou podpory aj zameraním. Pre účely testovania hry bola zvolená distribúcia Ubuntu z dôvodu, že patrí medzi tie najobľúbenejšie pre bežného používateľa bez špeciálnych požiadaviek. Následne bolo nutné rozhodnúť, akým spôsobom bude tento OS nainštalovaný. Distribúcia spustená z prenosného disku rovnako ako virtualizovaná verzia majú rôzne obmedzenia a nedokážu spoľahlivo nasimulovať reálne použitie. Zvolili sme tzv. \enquote{dual boot}, teda nainštalovania OS Linux \enquote{vedľa} hlavného OS na pracovnej stanici. Inštalácia prebehla v poriadku, problém bol však so spúšťaním. PC bez opýtania bootoval do OS Windows a nebolo možné vybrať OS pri štarte. Tento problém sa nakoniec podarilo vyriešiť zmenou poradia bootovania v rámci jedného disku. Táto možnosť bola pomerne dobre schovaná v BIOSe a bolo nutné uviesť Ubuntu na prvé miesto. To spôsobí, že pri každom štarte sa spustí program GRUB zodpovedný práve za zavádzanie OS a v rámci neho je možné vybrať, ktorý OS bude aktuálne spustený.

Operačný systém bol teda pripravený a mohlo sa prejsť na zostavenie hry. Po niekoľkých neúspešných pokusoch sa zistilo, že IL2CPP zostavenie nie je momentálne možné aj napriek nainštalovanému príslušnému modulu. Jednalo sa o chybu, ktorú som nahlásil spoločnosti Unity Technologies a nasledujúce zostavenia už prebiehali výlučne v režime mono. 

Zostavené verzie hry sa ukladajú na server pripojený do lokálnej siete. Na tomto serveri je nainštalovaný bežný OS Windows a dáta sú prístupné pomocou mechanizmu zdieľanej zložky. Na prístup k tejto zložke z OS Linux bol použitý program Gigolo, ktorý na tento úkon využíva štandard SAMBA. Stačilo sa teda pripojiť na server a spustiť zostavený program.

Tento prístup fungoval s testovacou aplikáciou, problém však nastal pri pokuse spustiť hru priamo vo virtuálnom súborovom systéme GVfs. Hra sa spustila ale všetky pokusy o načítanie herného sveta skončili chybovou hláškou. Možným riešením sa ukázalo kopírovanie zostavenej hry do lokálneho PC. To však nie je veľmi efektívne nakoľko bolo niekoľkokrát denne nutné presúvať herné súbory, ktorých veľkosť presahuje 20GB. Postupne sa zistilo, že spustená hra nedokáže v GVfs získať výlučný zámok na súbory s uloženými pozíciami. Tie sa generujú automaticky pri pokuse o vytvorenie nového herného sveta. Tento problém sa nakoniec podarilo vyriešiť zásahom do kódu hry. Do vytvárania \textit{FileStreamu} zo súboru bolo nutné explicitne pridať parametre \textit{FileMode.Open}, \textit{FileAccess.Read} a \textit{FileShare.Read}. Po tomto zásahu už bolo možné vstúpiť do hry a testovať.

Testovanie ukázalo hneď niekoľko závažných problémov. Jedným z nich, viditeľným na prvý pohľad, bola absencia intra. Intro je realizované ako videoklip a úlohou enginu Unity je ho len prehrať. Aby sa garantovalo správne prehratie na všetkých platformách zdrojový videoklip musí prejsť tzv. \enquote{transcodingom}. Táto operácia je voliteľná, v projekte sa však využívala. \enquote{Transcoding} má hneď niekoĺko nastaviteľných možností a najdôležitejšou je výstupný kodek. Ten bol nastavený na automatický výber podľa platformy, táto možnosť však nefungovala korektne a bolo nutné explicitne zvoliť kodek vp8, ktorý má natívnu podporu na všetkých cieľových platformách.

Druhý problém sa prejavil pri pokuse zmeniť rozlíšenie hry. Užívateľ môže rozlíšenie nastaviť v nastaveniach hry pomocou šípok doprava a doľava. Tieto rozlíšenia sú zoradené podľa zobrazeného počtu pixelov vzostupne a nie je možné preskakovať mimo poradia. Problém sa prejavoval pri pokuse zmeniť rozlíšenie z 640x480 na 1920x1080 a z rozlíšenia 1680x1050 opäť na 1920x1080. Táto hodnota je natívne rozlíšenie monitora, na ktorom bola hra spustená. Ukázalo sa, metóda \textit{Screen.currentResolution} dostupná v engine Unity vracala rozdielne hodnoty v závislosti od operačného systému. Na OS Windows táto metóda vracala nastavené rozlíšenie hry, ktoré mohol užívateľ ovplyvniť a na OS Linux vracala rozlíšenie monitora. Táto metóda bola použitá z dôvodu optimalizácie a kontrolovala, či zmena rozlíšenia v hre zapríčinená užívateľským kliknutím na šípku nastala medzi dvoma rozdielnymi rozlíšeniami. Nakoľko ale na OS Linux táto metóda vracala vždy 1920x1080, pokusy zmeniť rozlíšenie práve na túto hodnotu vždy zlyhali. Problém vyriešila mierne odlišná implementácia tejto logiky založená na metóde \textit{Screen.safeArea}.

Po vytvorení a vstupe do nového herného sveta sa ako ďalší problém ukázal počet snímkov za sekundu. Ten v priemere dosahoval 15fps, čo nie je hrateľná hodnota. Pripojenie hry na vzdialený PC so spusteným programom Unity Profiler, ktorý bol spomenutý už v sekcií \ref{sec:optim} ukázalo, že ohromné množstvo výkonu využíva metóda zodpovedná za integráciu so službou Steam. Tento problém som nahlásil kolegovi a ten musel aktualizovať Steam API na najnovšiu verziu. Aktuálne využívaná však bola stará niekoľko rokov, čo činilo problém, nakoľko API za tú dobu prešlo razantnými zmenami v implementácií, ktoré bolo nutné zohľadniť aj v kóde hry.

Posledným závažným problémom bola nemožnosť otáčania hernej kamery resp. rozhliadnutia sa v plnom rozsahu 360$^{\circ}$. Reálne dostupný uhol bol pocitovo asi polovičný. Kurzor myši je v hre skrytý pokiaľ hráč neotvorí menu alebo inventár a práve v inventári bolo vidieť, že moment, kedy prestane byť možné ďalej sa rozhliadať je zároveň momentom, kedy kurzor narazí na kraj obrazovky. Na OS Windows je však uzamknutý v jej strede, pokiaľ nie je viditeľný. Na OS Linux bolo nutné explicitne pri zneviditeľnení kurzora vždy nastaviť aj vlastnosť \textit{Cursor.lockState} na hodnotu \textit{CursorLockMode.Locked}. To umožnilo pohyb kamery v celom rozsahu, stále však boli mierne odlišnosti medzi chovaním na OS Windows a OS Linux. Túto diverzitu sme sa nakoniec rozhodli zachovať, nakoľko nijak neovplyvňuje zážitok z hry.

Jedným z ďalších nedostatkov, ktoré sa ešte podarilo nájsť bola neprimeraná veľkosť kurzoru v rámci minihry stieranie žrebu. Ten bol niekoľkonásobné väčší ako na OS Windows. Kurzor mal v rámci tejto minihry nastavený tzv \enquote{sprite} namiesto predvoleného výzoru a na OS Linux nefungovalo správne škálovanie tohto \enquote{spritu}. Tento problém sa podarilo opraviť zmenou veľkosti zdroja priamo na požadovanú hodnotu, ktorá vyhovovala na všetkých operačných systémoch bez nutnosti ďalších úprav tejto veľkosti kódom.

V hre sa aj naďalej vyskytovali menšie problémy, bola však bez prekážok hrateľná. Niektoré ďalšie nájdené problémy boli pomocou aplikácie \enquote{Mantis Report} zo sekcie \ref{sec:Report} nahlásené a ďalšie testovanie či opravy chýb boli prenechané povolanejším osobám.

\section{Ostatné projekty}
\label{sec:Others}
\subsection{Systém líhania hráčskej postavy}
\label{sec:sleep}
\textbf{Časová náročnosť:} \\ Nasadenie: 6 dní, pridanie dodatočnej funkcionality: 2 dni.\\
\textbf{Úvod do problému:} \\ V hre Hobo: Tough Life je relatívne veľké množstvo miest, na ktorých sa hráčska postava môže uložiť k spánku. Niektoré sú statické, s inými môže hráč manipulovať. Pôvodný systém, ktorý zabezpečoval, že hráčška postava je pri líhaní na správnom mieste a v správnej rotácií bol založený na tzv. \enquote{collideroch}. Väčšinou ide o zjednodušenú reprezentáciu objektu samotného, ktorá slúži na zabezpečenie korektnej kolízie medzi objektami. Tento prístup však vyžadoval relatívne presný \enquote{collider} okolo objektu určeného na spanie, čo bolo nie vždy zabezpečené. Mojou úlohou bolo teda vytvoriť robustný algoritmus, ktorý zaistí ležanie postavy v správnej polohe a to za každých okolností.  \\
\textbf{Realizácia:} \\ Po prvotnej analýze problému som sa rozhodol využiť skutočnosti, že každý objekt, na ktorom sa dá späť má nad sebou interakčnú ikonku. Pozíciu tejto ikonky som využil ako vstup môjho algoritmu. Z pozície ikonky som teda vystrelil tzv. \enquote{raycast} smerom dole.\enquote{Raycast} je možné predstaviť si ako vrhnutý lúč z počiatočného bodu určitým smerom, ktorý vráti informáciu o tom, s čím kolidoval.

Prvotný lúč slúžil na zistenie referenčnej vzdialenosti od ikonky, nakoľko sa interakčná ikonka nachádza vždy nad stredom objektu, táto vzdialenosť určovala zároveň výšku nad zemou, v ktorej bude hráč ležať. Táto referenčná vzdialenosť slúžila aj v ďalších krokoch algoritmu. Pri nastavení rozumnej tolerancie bolo možné určiť kde sa ešte nachádza spiaca plocha a kde už je zem, rám postele, operadlo či iný druh opierky. 

V prvej iterácií algoritmu sa počítalo s tým, že po vystrelení prvého lúča sa posunie pozícia bodu z ktorého bol vrhnutý o nejaký malý odstup v smere osy x a z a to najskôr v kladnom smere a potom v zápornom. Z každého takéhoto bodu sa znova vrhne lúč smerom dole a pokiaľ bude vzdialenosť v ktorej s niečím zkoliduje väčšia či menšia ako je tolerovaná hodnota táto pozícia sa zaznamená ako hranica spiacej plochy. Ak by sa takáto hranica nenašla algoritmus mal obmedzený počet lúčov v každom smere, ktoré mohol vrhnúť, aby nedošlo k zacykleniu. Následne už len stačilo vyrátať vzdialenosti medzi získanými štyrmi hraničnými bodmi, čo umožňovalo zistiť dlhšiu stranu, s ktorou bude postava pri ležaní zvierať menší uhol. Tento spôsob sa ukázal ako nedostatočný nakoľko pri určitej rotácií objektu sa postava ukladala po uhlopriečke alebo zachádzala do operadla.

V druhej iterácií sa už nevrhal lúč z prázdneho miesta ale pre lepšiu názornosť bol vytvorený na pozícií interakčnej ikonky prázdny objekt zvaný \enquote{Raycaster}, s ktorým bolo možné pohodlnejšie manipulovať a postupne ho posúvať. Miesto kríža bol zvolený kruh. \enquote{Raycaster} sa teda vždy posunul o nejaký malý určený uhol až kým neobišiel 360$^{\circ}$ okolo pôvodnej pozície a v každom smere sa ešte posúval o malý odstup až kým nenarazil na hranicu spiacej plochy alebo na obmedzenie vyplývajúce z maximálneho počtu vrhnutých lúčov v jednom smere. Súradnice hraničných bodov boli potom uložené do poľa s veľkosťou $360/\alpha$, kde $\alpha$ značí zvolený uhol. 

Pre ladenie algoritmu boli \enquote{raycasty} vykreslené pomocou metódy \textit{Debug.DrawRay}. Bežný lúč bol vyznačený zelenou farbou a krajný červenou. Mohla nastať aj varianta, že podlaha nebude mať \enquote{collider}, prípadne sa \enquote{Raycaster} dostane dovnútra prekážky a vrhnutý lúč nič nezasiahne. Túto situáciu som zvýraznil modrou farbou, pozícia takéhoto bodu bola však validná a teda opäť uložená do poľa. Vizualizáciu algoritmu je možné vidieť na \mbox{obrázku \ref{pic:algviz}}.

Veľkosti uhlov aj odstupov sa ladili pre dosiahnutie čo najlepších výsledkov. Nakoľko tento výpočet prebieha v editore a jeho výstup je serializovaný spolu s ďalšími údajmi o konkrétnom objekte, ako napríklad bonus ku spánku, nebol veľký tlak na pomer cena/výkon. Začínalo sa na uhle 45$^{\circ}$, finálny uhol bol však po testovaní stanovený až na 10$^{\circ}$, čo zabezpečovalo za každých okolností rovnobežnú pozíciu so spiacou plochou. Odstup na výsledok algoritmu nemá až taký veľký vplyv, priveľká benevolentnosť by však mohla spôsobiť, že postava bude zachádzať do rámu postele ši operadla lavičky. Odstup bol teda nastavený na hodnotu \textit{0.15f}. Tolerancia nerovnosti povrchu bola potom \textit{0.1f}. 

\begin{figure}[!htbp]
	\centering
	\includegraphics[width=1\textwidth]{Pictures/algviz.png}
	\caption{Vizualizácia algoritmu líhania postavy}
	\label{pic:algviz}
\end{figure}

Algoritmus môže teda vrhnúť v najhoršom prípade až $360/\alpha * rmax$ lúčov, čo pri veľkosti uhla $\alpha = 10^{\circ}$ a maximálnom možnom počte lúčov v jednom smere $rmax = 15$ znamená až 540 \enquote{raycastov} na každý objekt určný na spanie. Takýchto statických objektov je v hre 42 a manipulovateľných sú nižšie jednotky. Všetky hodnoty sa generujú naraz po spustení príkazu z horného panela v Unity Engine. Konkrétny časový rozsah sa netestoval, nakoľko na pracovných staniciach je tento proces prakticky okamžitý a hráč ním nie je nijak zdržovaný.

Získanie referenčnej vzdialenosti a krajných bodov objektu pomocou \enquote{raycastov} je možné vidieť vo výpise \ref{src:findEdges}.

\vspace{10pt}
\begin{lstlisting}[label=src:findEdges,caption={Získanie referenčnej vzdialenosti a krajných bodov objektu}]
private static Vector3[] FindEdges(int dirs, Vector3 iconPos, ref float refDist) {
    Vector3[] edges = new Vector3[dirs];
    GameObject rayCaster = new GameObject("RayCaster");
    rayCaster.hideFlags = HideFlags.DontSaveInEditor;
    Transform rayCasterTr = rayCaster.transform;

    Physics.Raycast(iconPos, Vector3.down, out RaycastHit rHit, 2f);
    refDist = rHit.distance;

    if (refDist != 0) {
        for (int i = 0; i < dirs; i++) {
            rayCasterTr.position = iconPos;
            rayCasterTr.eulerAngles = new Vector3(0, i * angle, 0);

            for (int j = 0; j < numOfRaysForDir; j++) {
                Vector3 currentPos = rayCasterTr.position;
                Physics.Raycast(currentPos, Vector3.down, out RaycastHit hit, 2f);

                if (hit.transform != null) {
                    if (IsNotSimilarToRef(hit.distance, refDist)) {
                        edges[i] = currentPos;
                        break;
                    }
                }
                else {
                    edges[i] = currentPos;
                    break;
                }
                rayCasterTr.Translate(new Vector3(0, 0, offset), Space.Self);
            }
        }
        Object.DestroyImmediate(rayCaster);
        return edges;
    }
    Object.DestroyImmediate(rayCaster);
    return null;
}
private static bool IsNotSimilarToRef(float distance, float referenceDistance) {
    return (distance > referenceDistance + tolerance) || (distance < referenceDistance - tolerance);
}
\end{lstlisting}

Na určenie správnej rotácie sa pôvodne zvažovalo riešenie, ktoré by prešlo všetky získané krajné body a hľadalo v ich súradniciach podobnosti. Najväčší počet za sebou idúcich bodov, ktoré by vykazovali takúto podobnosť by bol potom považovaný za priamku rovnobežnú s dlhšou časťou spiacej plochy a podľa nej by sa hráčska postava uložila k spánku. Problém s týmto riešením bol, že len niektoré body vykazovali väčšiu odlišnosť v nejakej súradnici od ostatných a nebolo teda jednoduché určiť, ktoré z nich skutočne ležia na takejto pomyselnej priamke a ktoré už nie. Navyše aj tie, ktoré na priamke ležali vykazovali mierne odchýlky v závislosti od aktuálneho uhla a odstupu.

Zvažovala sa taktiež možnosť postavená na hľadaní najväčšej vzdialenosť medzi dvoma bodmi. Ako sa ukázalo, táto vzdialenosť však vo väčšine prípadov ukazuje na uhlopriečku danej plochy. Rovnako nebolo možné použiť ani variantu s dvoma uhlopriečkami a nejakého spriemerovania súradníc medzi nimi nakoľko v niektorých rotáciách by to nevracalo korektné výsledky. 

Ako lepšie riešenie sa ukázalo použite rovnostranného trojuholníka s vrcholom v bode, kde sa nachádza pozícia ikonky, teda stred objektu. Týmto trojuholníkom by bolo možné rotovať okolo tohto stredu a v každej rotácií zaznamenávať, koľko krajných bodov sa podarilo obsiahnuť. Táto varianta narážala na problém so zvolením veľkosti trojuholníka, ktorá by sa musela v závislosti od danej rotácie meniť, aby lepšie kopírovala objekt nad ktorým rotuje. Na podobnej myšlienke sa však skutočne založilo aj finálne riešenie. Miesto rovnostranného trojuholníka bol však použitý úzky, dlhý kváder, ktorý postupne prejde všetky krajné body a súradnicu svojho stredu nastaví na súradnicu aktuálneho bodu. V tomto momente bolo nutné ešte kvádrom zarotovať, aby sa nasmeroval kolmo k stredovému bodu. V každom bode sa potom pomocou algoritmu AABB zisťovalo, koľko krajných bodov kváder obsahuje. V bode, v ktorom sa podarilo kvádru obsiahnuť najviac krajných bodov, bola jeho rotácia hľadaným výsledkom algoritmu. Tento postup je znázornený vo výpise \ref{src:findRot}

\vspace{10pt}
\begin{lstlisting}[label=src:findRot,caption={Získanie korektnej rotácie hráčskej postavy pri ležaní}]
private static int FindRotation(int dirs, Vector3 iconPos, Vector3[] edges) {
    GameObject cube = GameObject.CreatePrimitive(PrimitiveType.Cube);
    cube.name = "RotationFinder";
    cube.hideFlags = HideFlags.DontSaveInEditor;
    Transform cubeTransform = cube.transform;
    cubeTransform.localScale = new Vector3(0.2f, 0.2f, 2.5f);
    int resultIdx = -1, max = 0;
    Vector3 direction;
    float distance;
    for (int i = 0; i < dirs; i++) {
        direction = (iconPos - edges[i]).normalized;
        distance = Vector3.Distance(edges[i], iconPos);

        cube.transform.position = iconPos - direction * distance;
        cube.transform.rotation = Quaternion.LookRotation(Vector3.Cross(iconPos - edges[i], Vector3.up));

        int temp = 0;
        BoxCollider col = cube.GetComponent<BoxCollider>();
        for (int j = 0; j < dirs; j++) {
            if (PointInAABB(edges[j], col))
                temp++;
        }

        if (temp > max) {
            max = temp;
            resultIdx = i;
        }
    }
    Object.DestroyImmediate(cube);
    return resultIdx;
}
private static bool PointInAABB(Vector3 point, BoxCollider box) {
    point = box.transform.InverseTransformPoint(point) - box.center;

    float halfX = (box.size.x * 0.5f);
    float halfY = (box.size.y * 0.5f);
    float halfZ = (box.size.z * 0.5f);

    return point.x < halfX && point.x > -halfX && point.y < halfY && point.y > -halfY && point.z < halfZ && point.z > -halfZ;
}
\end{lstlisting}

Posledným problémom nutným riešiť bol smer pohľadu postavy pri ležaní. Keď postava spí, hráč môže stále očami postavy vidieť okolie. To ale nie je možné pokiaľ sa postava otočí na spánok tvárou k stene prípadne operadlu. Z toho dôvodu bola implementovaná metóda \textit{NeedToReverseDirection}, ktorá vrhne dva lúče, každy opačným smerom a pokiaľ to je nutné, vynúti otočenie hráčškej postavy o 180$^{\circ}$. Táto metóda spolu so vstupným bodom algoritmu je znázornená vo výpise \ref{src:entry}.

\vspace{10pt}
\begin{lstlisting}[label=src:entry,caption={Vstupný bod algoritmu na získanie rotácie a pozície postavy pri ležaní}]
public static void FindDistanceAndRotation(Vector3 iconPos, ref float distance, ref float restRotationY) {
    Assert.IsTrue(360 % angle == 0);
    int dirs = (int)(360 / angle);
    float referenceDistance = 0;
    Vector3[] edges = FindEdges(dirs, iconPos, ref referenceDistance);

    if (edges != null) {
        int resultIdx = FindRotation(dirs, iconPos, edges);
        Vector3 rawDirection = iconPos - edges[resultIdx];
        Vector3 rotation = Quaternion.LookRotation(rawDirection, Vector3.up).eulerAngles;

        if (NeedToReverseDirection(iconPos, rawDirection))
            restRotationY = rotation.y + 180;
        else
            restRotationY = rotation.y;

        distance = referenceDistance;
    }
}
private static bool NeedToReverseDirection(Vector3 iconPos, Vector3 rayCastDir, uint id = 0) {
    Physics.Raycast(iconPos, rayCastDir, out RaycastHit first, 2f);
    Physics.Raycast(iconPos, -rayCastDir, out RaycastHit second, 2f);

    if (first.distance != 0 && second.distance != 0)
        return second.distance > first.distance;
    else
        return second.distance == 0;
}
\end{lstlisting}

Ako som už spomínal, hodnoty, ktoré vráti tento algoritmus sú serializované spolu s ďalšími vlastnosťami objektu určeného na spanie. Keď hráč príde k danému objektu, tieto hodnoty si vyžiada, upraví podľa nich svoju pozíciu a rotáciu a spustí sa animácia líhania.

Objekty, ktoré hráč môže v hre posúvať a rotovať majú tieto hodnoty predpočítané tiež a to na mieru podľa ich pozície a rotácie po vyexportovaní z modelovacieho nástroja. Následná manipulácia s týmito objektami pripočítava príslušné prírastky k týmto predpočítaným hodnotám. Ak teda algoritmus zistí, že správna rotácia je 90$^{\circ}$ a hráč s objektom zarotuje napríklad o ďalších 30$^{\circ}$, pri pokuse ľahnnúť si je hráčskej postave vrátená hodnota 120$^{\circ}$.

\chapter{Záver}
\section{Teoretické a praktické znalosti a zručnosti získané v priebehu štúdia, uplatnené v priebehu odbornej praxe}
V rámci odbornej praxe som mal možnosť využiť širokú škálu znalostí nadobudnutých počas bakalárskeho štúdia. Menovite šlo o znalosti z predmetov ako Programovací jazyky I \& II, Tvorba aplikací pro mobilní zařízení II, Základy počítačové grafiky, Modelování v grafických aplikacích, Počítačové sítě a ďalších. 

Predmet Programovací jazyky II sa priamo zaoberal jazykom C\# a jeho pokročilejšími možnosťami ako udalosti, delegáti, lamda výrazy či LINQ, ktoré mi boli veľmi nápomocné počas celého obdobia praxe, nakoľko prevažná väčšina projektov prebiehala práve v tomto jazyku. Napriek tomu, že predmet Programovací jazyky I bol zameraný na platformu JAVA, odniesol som si z neho dobré základy syntaktickej analýzy textu či regulárnych výrazov, ktoré boli použiteľné aj mimo túto platformu. S regulárnymi výrazmi som sa zároveň stretol aj v predmete Úvod do teoretické informatiky i keď v trochu inej forme. Pomohlo mi to však k hlbšiemu pochopeniu danej problematiky. 

V predmetoch Programovací jazyky I a Tvorba aplikací pro mobilní zařízení II som mal zároveň v rámci semestrálnych projektov možnosť pracovať na jednoduchých hrách, čím som okrem základneho povedomia o kruciálnych pojmoch herného vývoja prehĺbil svoje znalosi objektovo orientovaného programovania. To mi neskôr uľahčilo orientáciu v kóde hry Hobo: Tough Life a zároveň aj integráciu vlastných riešení.

Počas štúdia som sa zároveň hneď na niekoľkých predmetoch stretol s tvorbou užívateľského rozhrania vo Windows Forms, čo som následne využil pri tvorbe vývojárských nástrojov. K môjmu prekvapeniu prišli vhod aj znalosti sieťových protokolov získané v predmete Počítačové sítě.

Veľmi užitočné bolo aj povedomie o matematických princípoch využívaných v počítačovej grafike, ktoré som nadobudol v predmete Základy počítačové grafiky či vedomosti týkajúce sa textúr, 3D modelov a ďalších vecí získané v predmete Modelování v grafických aplikacích.

\label{sec:techZruc}
\section{Znalosti a zručnosti chýbajúce v priebehu odbornej praxe}
\label{sec:coNeviem}
Počas vysokoškolského štúdia som získal solídne základy programovania ako takého, chýbali mi však skúsenosti s nejakým herným enginom. V predmete Základy počítačové grafiky sme sa síce pokúšali naprogramovať jednoduchý engine prakticky od nuly, čo pomohlo k pochopeniu niektorých princípov, ocenil by som však možnosť v rámci štúdia pracovať aj v nejakom komerčne využívanom. S týmto problémom som však počítal a snažil sa doplniť potrebné medzery ešte pred nástupom na prax v rámci voľného času. Chýbali mi taktiež skúsenosti s prácou s webovými technológiami ako REST API, klient server architektúrou a celkovo som mal nedostatočné znalosti týkajúce sa problematiky prenosu dát cez internet. Problém som mal taktiež s integráciou rôznych API od tretích strán či používaním verzovacieho systému v rámci týmu. Tieto nedostatky sa prejavovali primárne v prvých dňoch odbornej praxe.

\section{Dosiahnuté výsledky v priebehu odbornej praxe a celkové zhodnotenie}
\label{sec:Results}
Odbornú prax v spoločnosti Perun Creative hodnotím ako skvelú pracovnú skúsenosť. Mal som možnosť uplatniť svoje znalosti a zručnosti na veľmi zaujímavom a netradičnom projekte akým je počítačová hra Hobo: Tough Life. Rovnako som nadobudol veľké množstvo tvrdých čí mäkkých zručností, ktoré sú neprenositeľné. Každého človeka zároveň poteší pohľad na to, ako sú plody jeho práce denno denne využívané aby uľahčovali a spríjemňovali prácu ostatným. Z tohto pohľadu výsledky vývoja pomocných nástrojov predčili všetky moje očakávania. Prevod hry na ďalšie platformy, na ktorom som sa podieľal, je v dobe písania tohto textu stále relatívne na začiatku a naplno sa rozbehne až po vydaní hry. Z mojej strany boli však položené pevné základy, pripravené pre budúce potreby. 
Hráči sa potom budú môcť stretnúť s mojou prácou skôr symbolicky, keď sa budú ukladať k spánku na zastávke, lavičke či inom útulnom mieste. Dúfam, že tento stav sa zmení v ďalšom projekte, nakoľko plánujem v tomto hernom štúdiu ostať pracovať aj po skončení odbornej praxe a naďalej tak prehlbovať svoje odborné znalosti.

\printbibliography[title={Literatúra}, heading=bibintoc]
\end{document}