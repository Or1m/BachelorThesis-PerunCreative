\documentclass[slovak, bachelorpractice]{diploma}

% Packages (balíky makier)
\usepackage[autostyle=true, czech=quotes]{csquotes} % korektná sadzba úvozoviek, podpora pre balík biblatex
\usepackage[backend=biber, style=iso-numeric, alldates=iso]{biblatex} % bibliografia
\usepackage{dcolumn} % stĺpce tabuľky s číselnými hodnotami
\usepackage{subfig} % makrá pre "podobrázky" a "podtabuľky"
\usepackage[csharp]{diplomalst} % sádzanie 
\usepackage{color}

% Novy druh tabuľkového stĺpca, v kterom sú čísla zarovnané podľa desetinnej čiarky
\newcolumntype{d}[1]{D{,}{,}{#1}}

\lstdefinelanguage{yml}{
  morekeywords={variables, GIT_CLONE_PATH, GIT_CLEAN_FLAGS, unity-build, stage, only, script, tags},
  alsoletter=-,
}

\lstdefinestyle{Batch}{
morekeywords={SET, @ECHO, ECHO, IF, EXIT, START, ELSE, GTR},
deletekeywords={var, is}
}

\makeatletter
\lst@InstallKeywords k{methods}{methodstyle}\slshape{methodstyle}{}ld
\lst@InstallKeywords k{classes}{classstyle}\slshape{classstyle}{}ld
\lst@InstallKeywords k{properties}{propsstyle}\slshape{propsstyle}{}ld
\makeatother

\definecolor{methods}{rgb}{.45, .33, .12}
\definecolor{classes}{rgb}{.12, .40, .16}
\definecolor{words}{rgb}{.17, .57, .69}
%\definecolor{props}{rgb}{0, 0, 0}

\lstset{
 moremethods={ExecutePost, GetUri, SendIssue, SerializeObject, ReadToEnd, Parse, OnUpdate, StartCreateReport, ZipAndSendToLinkManager, Log, StartCoroutine, LocalIPAddress, ToString, Exists, Delete, WriteAllText, OpenURL, WaitForSeconds, EnumerateFiles, Contains, AddFile, Save, ReadAllBytes, Send_MantisReport, ToBase64String, AcceptTcpClient, GetStream, Read, GetString, CreateReport, GetWindowRect, GetActiveWindow, GetUnityBounds, pictureBoxBcg_MouseDown, pictureBoxBcg_MouseUp, pictureBoxBcg_MouseMove, Invalidate, DrawLine, InvokePowershellScript, AddScript, Invoke, Select, ToArray, Create, Format, ToHex, Matches, FromJson, ReadAllText, PrintListToJsonString, ToJson, LoadAssetAtPath, FindProperty, OnEnable, OnInspectorGUI, ApplyModifiedProperties, PropertyField, SetUpScenes, Add, GetValues, IsSelected, ToInt32, BuildWindows, BuildPlayer, GetBuildOptions},
 methodstyle=\bfseries\color{methods},
 moreclasses={Issue, JsonConvert, JObject, Keyboard, Debug, HBTLink_Manager, GameConfiguration, File, Application, ZipFile, Directory, SearchOption, Convert, TcpClient, NetworkStream, Encoding, Rect, Screen, IntPtr, MouseEventArgs, Point, PowerShell, GitLogger, Regex, Message, Content, Serialize, MenuItem, DllImport, AssetDatabase, BuildSettings, SerializedProperty, CustomEditor, EditorGUILayout, Editor, BuildSettingsEditor, Enum, Array, List, Scene, BuildPlayerOptions, BuildTarget, BuildTargetGroup, BuildResult, BuildReport, BuildPipeline, WindowsSettings},
 classstyle = \bfseries\color{classes},
 morekeywords={endif, var, yield, get, set},
 %properties={isPressed, wasPressedThisFrame, current, f11Key, leftShiftKey, UNITY_EDITOR, sender_ServerIP, Instance, pathConfig, exeFile, mantisArguments, FullName, AllDirectories, System},
 %propsstyle=\bfseries\color{props}
}

% ------------------------------------------------------

% Titulné strany
\ThesisAuthor{Miroslav Kačeriak}
\ThesisSupervisor{Ing. Pavel Dohnálek, Ph.D.}
\SubmissionYear{2021}

% Poďakovanie
\Acknowledgement{Rád by som na tomto mieste poďakoval mojím dvom kolegom, a zároveň zakladateľom herného štúdia Perun Creative, Bc. Jánovi Polachovi a Bc. Jirkovi Vašicovi za prejavenú dôveru, trpezlivosť a ochotu pomôcť počas absolvovania odbornej praxe. Poďakovanie patrí aj mojej priateľke za podnetné rady a postrehy poskytnuté pri písaní tejto práce.}

% Abstrakty
\CzechAbstract{Cieľom tejto bakalárskej práce je popísať absolvovanie odbornej praxe v českom nezávislom hernom štúdiu Perun Creative. Prvá časť si kladie za cieľ charakterizovať štúdio ako také a uviesť základnú klasifikáciu vyvíjaného produktu, teda počítačovej hry Hobo: Tough Life. Následne by som chcel špecifikovať moje pracovné zaradenie v rámci štruktúry spoločnosti a uviesť najdôležitejšie technológie, s ktorými som mal možnosť pracovať. Hlavnú časť tejto práce tvorí popis realizácie konkrétnych projektov. Tie sa týkali najmä vývoja pomocných nástrojov, optimalizácie a prevodu hry na iné platformy, ale aj implementácie konkrétnych herných mechaník. Záver je potom venovaný celkovému zhodnoteniu absolvovanej odbornej praxe so zameraním na uplatnené a novonadobudnuté znalosti a zručnosti.}

\CzechKeywords{Unity engine, C\#, herný vývoj, automatizácia, optimalizácia, vývojárske nástroje}

\EnglishAbstract{Main purpose of this bachelor thesis is to describe how my individual professional practise in czech indie game studio Perun Creative went. First part aims to characterize the studio as such and give a basic classification of the developed product, i.e. the computer game Hobo: Tough Life. Afterwards, I would like to specify my position within the company structure and mention the most important technologies that I had the opportunity to work with. The main part of this thesis is dealing with the implementation of specific projects. These were mainly focused on the creation of development tools, optimization and porting of the game to other platforms, but also the implementation of some game mechanics. The conclusion is then aimed to the overall evaluation of the completed individual professional practice with focus on applied and newly acquired knowledge and skills.}

\EnglishKeywords{Unity engine, C\#, game development, automatisation, optimization, development tools}

% Skratky
\AddAcronym{API}{Application Programming Interface}
\AddAcronym{CD}{Continuous Delivery}
\AddAcronym{CD}{Continuous Deployment}
\AddAcronym{CI}{Continuous Integration}
\AddAcronym{CLR}{Common Language Runtime}
\AddAcronym{DLL}{Dynamic Link Library}
\AddAcronym{EOS}{Epic Online Services}
\AddAcronym{GC}{Garbage Collector}
\AddAcronym{HTTPS}{Hypertext Transfer Protocol Secure}
\AddAcronym{IL}{Intermediate Language}
\AddAcronym{IP}{Internet Protocol}
\AddAcronym{JIT}{Just-In-Time}
\AddAcronym{JSON}{JavaScript Object Notation}
\AddAcronym{LFS}{Large File Storage}
\AddAcronym{MSS}{Maximum Segment Size}
\AddAcronym{MTU}{Maximum transmission unit}
\AddAcronym{NPC}{Non-playable Character}
\AddAcronym{OS}{Operating System}
\AddAcronym{PC}{Personal Computer}
\AddAcronym{QA}{Quality Assurance}
\AddAcronym{REST}{Representational State Transfer}
\AddAcronym{RPG}{Role Playing Game}
\AddAcronym{SSH}{Secure Shell}
\AddAcronym{SSL}{Secure Sockets Layer}
\AddAcronym{TCP}{Transmission Control Protocol}
\AddAcronym{URL}{Uniform Resource Locator}
\AddAcronym{WPF}{Windows Presentation Foundation}
\AddAcronym{XML}{eXtensible Markup Language}

% Literatúra
\addbibresource{literature.bib}

% Samotný dokument
\begin{document}
\MakeTitlePages

% Chapter 1
\chapter{Úvod}
\label{sec:Introduction}
V rámci mojej odbornej praxe som dostal možnosť nahliadnuť za oponu herného vývoja v českom nezávislom štúdiu Perun Creative. Nakoľko sa o hry a herný priemysel dlhodobo zaujímam, táto firma a jej tvorba mi bola vopred známa. Aj po prednáške jej dvoch spoluzakladateľov a zároveň programátorov, ktorá sa uskutočnila v priestoroch Vysokej školy báňskej, som bol stále prekvapený vysokou technologickou úrovňou ich prvého projektu. Firmu som chcel kontaktovať so žiadosťou o prácu nezávisle od odbornej praxe, no keď som sa dozvedel, že už niekoho práve na odbornú prax hľadajú, rozhodol som sa to využiť. Pracovnému pohovoru predchádzalo zaslanie programátorského portfólia zloženého zo školských ale aj vlastných prác. Samotný pohovor potom prebiehal online s oboma programátormi Bc. Jánom Polachom a Bc. Jirkou Vašicou, ktorí sa neskôr stali aj mojimi kolegami.

Do firmy som nastúpil na konci životného cyklu projektu, takže som sa nemohol podieľať na vývoji základných herných mechaník. Naopak to znamenalo nutnosť dôkladne sa s celým projektom zoznámiť a pochopiť, ako jednotlivé časti fungujú. Počas praxe som sa podieľal na širokej škále väčších aj menších projektov z oblastí ako sú automatizácia a zefektívnenie vývojárskych či testerských postupov, nasadenie projektu, sieťová infraštruktúra a došlo aj na nejaké tie herné mechaniky. Pri riešení rôznych problémov mi okrem kolegov boli nápomocné aj rôzne teoretické znalosti nadobudnuté počas vysokoškolského štúdia.

% Section 2
\chapter{Popis firmy a pracovného zaradenia}
\label{sec:Firm and me}
% TODO: Overit info u Jirky
\section{Popis firmy a vyvíjaného produktu}
\label{sec:Firm}
Perun Creative s.r.o \cite{Perun} je české nezávislé herné štúdio, ktoré od roku 2015 vyvíja počítačovú hru Hobo: Tough Life \cite{Hobo}.

Hra samotná by sa dala charakterizovať ako RPG z mestského prostredia, kde sa hráč ocitne v role bezdomovca. Ústrednou hernou mechanikou je snaha prežiť v nehostinnom prostredí ulice. Okrem prežitia na hráča čaká aj pútavý príbeh a možnosť hrať kooperatívne až s troma ďalšími hráčmi. Hobo: Tough Life v súčasnosti vychádza na platformách Microsoft Windows a Linux. V budúcnosti sa počíta aj s vydaním na konzolách novej a starej generácie. 

Štúdio Perun Creative má aktuálne dve pobočky. Prvá sa nachádza v Ostrave a jej osadenstvo tvoria výhradne programátori. Pobočka v Olomouci naopak slúži pre menej technicky zameranú časť firmy a síce pre grafika, herného dizajnéra a komunitného manažéra. Štúdio tvorí menej ako desať vývojárov a teda sa svojou veľkosťou radí k menším. Využíva ale aj služby externých pracovníkov prípadne spoločností špecializovaných na testovanie, zvukovú stránku hry a v neposlednom rade aj na preklad textov do rôznych svetových jazykov.
\vspace{-5pt}
\begin{figure}[!htbp]
	\centering
	\includegraphics[width=0.8\textwidth]{Pictures/logoNew.jpg}
	\vspace{-5pt}
	\caption{Logo spoločnosti Perun Creative}
	\label{pic:perunLogo}
\end{figure}
\section{Pracovné zaradenie}
\label{sec:Me}
Môj prínos štúdiu Perun Creative spočíval hlavne v automatizácií a zefektívnení jednotlivých interných postupov resp. vývoji pomocných nástrojov pre QA oddelenie či ostatných programátorov. Do tejto kategórie by som zaradil projekty ako automatizované zostavenie hry na serveri, zefektívnenie spôsobu nahlasovania jednotlivých problémov prípadne prepracovanie importovania objektov zo starej verzie projektu do novej. K zefektívneniu práce rozhodne prispel aj návrh a implementácia systému klávesových skratiek v hernom engine Unity (bližšie popísanom v sekcií \ref{sec:Unity}) či  program na vytvorenie tzv. \mbox{\enquote{Patch notes}}. Ten bol primárne určený pre testerov, ale do budúcna sa plánuje jeho využitie aj pri informovaní hráčov o novinkách v rámci hry.

Okrem vyššie uvedených projektov som pracoval na novom systéme líhania postavy k spánku, optimalizácií a uvedeniu hry na OS Linux, prevode online časti hry z platformy Steam na platformu EOS a ďalších menších projektoch.
% End of section 2

% Section 3
\chapter{Použité technológie}
\label{sec:Tech}
V nasledujúcej kapitole by som rád v krátkosti zhrnul najdôležitejšie technológie, s ktorými som sa v rámci odbornej praxe stretol. Niektoré som aktívne využíval počas celého obdobia praxe a ich osvojovanie teda prebiehalo organicky. Iné boli špecifické pre konkrétny projekt a danú technológiu som si musel naštudovať počas realizácie projektu. V niektorých prípadoch bolo nutné sa zoznámiť s viacerými technológiami, aby som bol schopný posúdiť ich výhody a nevýhody pri nasadení na konkrétny projekt a vybrať tú správnu. Informácie som poväčšine čerpal z dokumentácií k daným technológiám aj keď nie vždy bola ich úroveň dostatočná.

\section{Programovací jazyk C\# a architektúra .NET}
\label{sec:CsharpDotNet}
C\# \cite{CSharpLang} je objektovo orientovaný, typovo bezpečný programovací jazyk umožňujúci vytvárať aplikácie v .NET ekosystéme. Syntax jazyka C\# vychádza z programovacích jazykov C a C++. Narozdiel od nich ale ponúka vyššiu úroveň abstrakcie. Tá sa prejavuje napríklad na úrovni správy pamäte, čo z jazyka C\# robí voľbu číslo jedna pre začínajúcich programátorov, ktorí by si chceli skúsiť herný vývoj na vlastnej koži.

Architektúra .NET \cite{CSharpLang} potom ponúka okrem virtuálneho stroja CLR, ktorý vykonáva JIT kompiláciu IL kódu do strojových inštrukcií, aj sadu veľmi užitočných knižníc. Tieto knižnice sú organizované do menných priestorov a poskytujú širokú škálu metód vhodných napríklad na prácu so súbormi či sieťovou infraštruktúrou. Veľmi užitočné sú aj nástroje na syntaktickú analýzu XML prípadne platforma Windows Forms, ktorá sa v rámci mojej odbornej praxe vo firme Perun Creative ukázala byť vhodná hlavne na rýchlu tvorbu vývojárskych nástrojov. Kvôli limitáciám tejto technológie sa ale v budúcnosti plánuje prechod na systém WPF.

\section{Unity Engine}
\label{sec:Unity}
Unity Engine \cite{Unity} je platforma pre tvorbu 2D a 3D interaktívneho obsahu renderovaného v reálnom čase. Najväčšie uplatnenie nachádza pri tvorbe malých až stredne veľkých hier, ale je čoraz častejšie využívaný aj v iných odvetviach ako napríklad automobilový či filmový priemysel. Je dostupný pre operačné systémy Windows, Linux a Mac OS. Distribuuje sa zdarma pre študentov alebo jednotlivcov do určitého finančného obratu a za ročný poplatok pre firmy, ktorého výška závisí od rôznych faktorov. Samotný engine je napísaný v jazyku C++ a umožňuje vývoj obsahu v jazyku C\# (bližšie popísanom v sekcií \ref{sec:CsharpDotNet}) pre širokú škálu platforiem, čo znázorňuje \mbox{obrázok \ref{pic:UnityPlatforms}}.

\begin{figure}[!htbp]
	\centering
	\includegraphics[width=1\textwidth]{Pictures/platforms.png}
	\caption{Platformy podporované Unity engine-om \cite{UnityMultiplatform}}
	\label{pic:UnityPlatforms}
\end{figure}

\section{Verzovací systém Git}
\label{sec:Git}
Git \cite{ProGit} je open source distribuovaný systém na správu verzií vyvinutý Linusom Thorvaldsom a komunitou okolo OS Linux v roku 2005. Umožňuje vrátiť celý projekt alebo vybrané časti do predchádzajúceho stavu, porovnávať zmeny v súboroch, prípadne efektívnu kolaboráciu viacerých vývojárov na spoločnom projekte. Každý člen tímu má k dispozícií kompletný repozitár vrátane histórie jednotlivých súborov, čo pridáva ďalšiu vrstvu ochrany proti výpadkom a poruchám hardvéru. Po každom spustení príkazu \textit{commit} sa uloží aktuálny stav projektu, ktorý je možné spätne dohľadať v prípade nejakého problému.

S gitom je možné pracovať priamo z príkazového riadku ale pre väčšie projekty ako je aj hra Hobo: Tough Life je takýto prístup značne nepraktický a neefektívny. Existuje ale množstvo programov tretích strán, ktoré umožňujú pracovať s gitom z užívateľského rozhrania. Jedným takým je aj nástroj Sourcetree, s ktorým som v rámci mojej odbornej praxe pracoval.

Nakoľko git samotný nie je dobre prispôsobený na správu verzií veľkých súborov, bolo nutné využívať aj jeho rozšírenie Git LFS. 
\section{GitLab CI/CD}
\label{sec:GitLab}
Gitlab CI/CD \cite{Cicd} je súčasť nástroja Gitlab a slúži na vývoj softvéru prostredníctvom kontinuálnych metód ako:
\begin{itemize}
  \item \textbf{Continuous Integration (CI)} - pre každé pridanie zmien do repozitára je možné automatizovane spustiť sadu skriptov, ktorých účelom je projekt zostaviť či otestovať.
  \item \textbf{Continuous Delivery (CD)} - pridáva ďalšiu vrstvu nad rámec CI, umožňuje zostavený a otestovaný kód nasadiť, vyžaduje to ale manuálnu akciu.
  \item \textbf{Continuous Deployment (CD)} - funguje podobne ako Continuous Delivery ale nasadenie prebieha automaticky.
\end{itemize}
Spoločnou filozofiou týchto metód je teda po každej iteratívnej zmene v projekte kód zostaviť, otestovať a prípadne aj nasadiť. Hlavnou výhodou takého prístupu je redukovanie množstva chýb, ktoré by sa inak dostávali do ďalších iterácií a mohli by spôsobiť problémy, keby neboli odchytené v zárodku. Zároveň si kladú za cieľ znížiť potrebu manuálneho zásahu do jednotlivých automatizovaných procesov na minimum.

V rámci mojej odbornej praxe som sa stretol hlavne s metódou CI. Možnosti automatizovaného testovania hry touto metódou sú veľmi obmedzené, o to viac je ale užitočné automatizované zostavenie na serveri. Zostavenie tohto typu projektu na pracovnej stanici je typicky náročne ako časovo tak aj na výpočtový výkon a do značnej miery teda spomaľuje vývoj ako taký. Bolo teda logickým krokom zamerať sa v rámci optimalizácie interných procesov aj na tento aspekt.

\begin{figure}[!htbp]
	\centering
	\includegraphics[width=.9\textwidth]{Pictures/gitlab.png}
	\vspace{-15pt}
	\caption{Princíp fungovania Gitab CI/CD \cite{Cicd}}
	\label{pic:Gitlab}
\end{figure}

\section{Epic Online Services}
\label{sec:Eos}
Epic Online Services alebo EOS \cite{Epic} je skupina nástrojov od spoločnosti Epic Games, ktoré sa snažia zjednodušiť a zjednotiť niektoré aspekty herného vývoja naprieč platformami. Typicky sa zameriavajú na kooperatívnu či kompetetívnu zložku hry pre viacerých hráčov, zahŕňajú však aj služby ako nákup herných predmetov za reálne peniaze, zber hráčskych štatistik, prípadne získavanie herných úspechov. Za normálnych okolností je nutné tieto služby implementovať zvlášť takmer pre každú platformu, na ktorú bude hra vychádzať. EOS sú zdarma dostupné pre vývojárov a podporujú širokú škálu platforiem, čo znamená väčšiu slobodu z pohľadu hráča ale aj z pohľadu vývojára. Hráč môže ďalej ťažiť aj z online synchronizácie postupu hrou naprieč viacerými platformami, prípadne z prístupu k úspechom či priateľom z jedného centrálneho miesta. 

Nakoľko sa do budúcna počíta s vydaním hry Hobo: Tough Life na rôzne platformy, ukázalo sa použitie EOS ako veľmi výhodné na náhradu doterajšieho systému pre hru viacerých hráčov. Hlavnou výhodou tohto riešenia by bola vyššie spomínaná multiplatformovosť. V dobe písania tohto textu sa však počíta s nasadením EOS spolu s niektorými službami dostupnými len na konkrétnej platforme.
% End of section 3

% Section 4
\chapter{Zadané projekty a ich riešenia}
\label{sec:Projects}
V tejto kapitole by som rád podrobne prebral konkrétne projekty na ktorých som v rámci mojej odbornej praxe pracoval. Poradie v akom budú prezentované nutne neodzrkadľuje poradie ich vypracovania, ale budú usporiadané do logických celkov podľa typu projektu. 

Čo sa časovej náročnosti týka, nie vždy je možné ju určiť presne nakoľko niektoré z projektov boli vyvíjané inkrementálne podľa spätnej väzby QA oddelenia alebo nových požiadaviek od ostatných programátorov.
%U niektorych prebiehala tvorba inkrementalne a bola zavisla na spatnej vazbe bla bla.

\section{Vývoj pomocných nástrojov pre QA oddelenie a programátorov}
\label{sec:QACode}
\subsection{Evidovanie chybových reportov (Mantis Report)}
\label{sec:Report}
\textbf{Časová náročnosť:} \\ Nasadenie: 8 dní, pridanie ďalšej funkcionality podľa požidaviek: spolu 8 dní.\\
\textbf{Úvod do problému:} \\ Ako som spomenul v sekcií \ref{sec:GitLab} možnosti automatizovaného testovania hry tohto rozsahu sú na rozdiel od bežného softvéru značne obmedzené. Veľké štúdiá si vytvárajú vlastné nástroje založené na umelej inteligencií, nikdy sa to však úplne neobíde bez ľudí z QA oddelenia ľudovo nazývaných aj ako testeri. Úlohou testera je teda hrať celú hru alebo jej určené časti, nájsť a následne ohlásiť nájdené chyby. 

Takéto ohlásenie chyby je značne neefektívny proces nakoľko na pozadí zahŕňa hneď niekoľko ďalších krokov ako minimalizácia hry, otvorenie stránky so službou Mantis Bug Tracker, nahranie snímky obrazovky a nakoniec aj samotné vyplnenie detailov reportu. Niektoré z týchto detailov sa navyše medzi jednotlivými reportmi nemenia ako napríklad informácie o platforme či operačnom systéme. Ručné vyplnenie reportu znázorňuje obrázok \ref{pic:Mantis}.
Táto neefektívnosť samozrejme priamo úmerne rastie s počtom nájdených chýb, čo môžu byť aj vyššie jednotky denne. Mojou úlohou bolo teda optimalizovať tento postup. \\
\textbf{Navrhované riešenia:} \\ Nakoľko bola toto moja prvá úloha v rámci odbornej praxe, mal som len minimálne skúsenosti s webovými technológiami ako je REST API a celkovo klient-server architektúrou, navrhol som riešenie postavené na nejakom nástroji na automatizovanie webového prehliadača. Takýmto nástrojom je napríklad Selenium WebDriver, s ktorým som sa stretol pri práci na vlastných projektoch. Ten je veľmi obľúbený napríklad pri testovaní webových aplikácií. Dokázal by zapnúť webový prehliadač, či už s užívateľským rozhraním alebo bez, otvoriť požadovanú stránku a vyplniť detaily reportu za užívateľa. V spojení s nejakým vlastným nástrojom na ukladanie snímky obrazovky, prípadne nástrojom, ktorý by testerovi umožnil vypísať zhrnutie či popis reportu priamo v hre by sa naozaj jednalo o relatívne dobré riešenie. Po užívateľovi by to ale vyžadovalo nutnosť inštalácie nejakého konkrétneho prehliadača v požadovanej verzií, aby bola zaistená správna kompatibilita a veľmi pravdepodobne by sa v budúcnosti objavili aj ďalšie problémy s nasadením či používaním. 

Po preskúmaní ďalších možností a následnej porade s kolegami som sa teda rozhodol dať prednosť riešeniu postavenému na už spomínanom REST API a ak by sa to ukázalo ako nerealizovateľné spätne sa vrátiť k môjmu prvému nápadu.
\vspace{-5pt}
\begin{figure}[!htbp]
	\centering
	\setlength{\fboxsep}{0pt}
	\setlength{\fboxrule}{1pt}
	\fbox {
		\includegraphics[width=0.68\textwidth]{Pictures/mantis.png}
	}
	\caption{Ručné vloženie reportu do služby Mantis Bug Tracker}
	\label{pic:Mantis}
\end{figure} \\
\textbf{Realizácia:} \\ Pri preskúmavaní možností založených na REST API som narazil na open source projekt MantisSharp \cite{MantisSharp}. Po zoznámení sa s týmto projektom a niekoľkými pokusmi ho \enquote{ohnúť} pre účely môjho projektu som sa rozhodol, že bude jednoduchšie napísať si aplikáciu sám. Využil som k tomu dve triedy z projektu MantisSharp, a síce \textit{RestClient} a \textit{MantisClient}, ktoré som následne ešte ďalej modifikoval. Trieda \textit{RestClient} vykonáva najnižšiu úroveň komunikácie so serverom a síce odosiela GET a POST žiadosti. Trieda \textit{MantisClient} má potom dve úlohy. Na jednej strane prijíma dáta z mojej aplikácie, zabalí ich do formy vhodnej pre transport a následne ich predá triede \textit{RestClient} na odoslanie metódou POST. Na strane druhej transformuje dáta získané zo servera pomocou metódy GET do C\# tried vhodných na následné použitie. Tento postup pridáva určitý level abstrakcie do celej aplikácie.

Problematiku odosielania dát na server som sa rozhodol demonštrovať na pridaní nového reportu vo výpise \ref{src:SendIssue}. Aplikácia vytvorí na základe vstupných dát inštanciu triedy \textit{Issue}, ktorú predá metóde \textit{SendIssue}. Tá ju následne zabalí ako JSON objekt a ďalej predá v metóde \textit{ExecutePost} na finálne odoslanie. Získavanie dát funguje obdobne len opačným smerom. 

Služba Mantis Bug Tracker po úspešnom pridaní nového reportu tento report vráti v odpovedi, čo som ďalej využil na informovanie užívateľa o úspešnom zaevidovaní, ktoré som doplnil o serverom pridelený identifikátor.
\vspace{10pt}
\begin{lstlisting}[label=src:SendIssue,caption={Odoslanie nového reportu na server}]
public int SendIssue(Issue issue) {
	string uri = this.GetUri(issuesUri);
	int id = -1;

	restClient.ExecutePost(uri, () => JsonConvert.SerializeObject(issue),
        reader => {
            string answerFromServer = reader.ReadToEnd();
            JObject obj = JObject.Parse(answerFromServer);
            id = (int)obj["issue"]["id"];
        });

    return id;
}
\end{lstlisting}
Server spočiatku na všetky žiadosti reagoval chybou \enquote{401 Unauthorized}. Po dôkladnom preskúmaní problému sa ukázalo, že chyba je na strane serveru a bolo nutné zasiahnuť do jeho kódu. Nakoľko som k tomuto kódu nemal prístup, požiadal som kolegu, či by mi s tým mohol pomôcť. Ukázalo sa, že server filtroval všetky požiadavky, ktoré sa pokúšali o autorizáciu pomocou tzv. \enquote{Bearer tokenu}. Spoločne sa nám tento problém však podarilo vyriešiť. 

Systém nahlasovania reportov mal byť pôvodne implementovaný ako súčasť hry. To sa ale ukázalo ako problematické z hľadiska zachytávania užívateľského vstupu v Unity engine. V praxi by to znamenalo, že ak by užívateľ popisoval chybu napríklad do nejakého textového poľa, hra samotná by naďalej vykonávala akcie na základe stlačených kláves. Rozhodli sme sa teda začleniť tento systém do už existujúceho vývojárskeho nástroja s názvom HoboThor. Tento nástroj je veľmi komplexný a jeho popis by bol nad rámec tejto kapitoly.

Logika aplikácie bola teda rozdelená do dvoch častí. Časť, s ktorou interaguje užívateľ bola realizovaná ako Windows Forms aplikácia začlenená do nástroja HoboThor a časť, ktorá túto aplikáciu spustí bola implementovaná priamo do hry a vyvolá sa stlačením klávesovej skratky Shift + F11, ak je hra spustená s podporou vývojárskych nástrojov. 

Kontrola, či boli stlačené konkrétne klávesy musí prebiehať každú snímku, aby sa zabezpečilo, že odchytenie prebehne úspešne. Kód zabezpečujúci túto funkcionalitu bol teda vložený do metódy \textit{OnUpdate} triedy \textit{ReportingManager}, čo znázorňuje výpis \ref{src:OnUpdate}. 

Projekt Hobo: Tough Life do veľkej miery stojí na hierarchickej štruktúre tried, tzv. \enquote{Manageroch}, ktorí, ako názov napovedá obstarávajú určité časti aplikácie. Metóda \textit{OnUpdate} triedy \textit{ReportingManager} je teda každú snímku volaná inou triedou, ktorá je vyššie v hierarchickej štruktúre projektu. Na najvyššom stupni hierarchie potom stojí trieda \textit{MainManager}. Tá obsahuje metódu \textit{Update}, ktorá je priamo volaná natívnym C++ kódom enginu Unity a táto metóda potom obsahuje volania metód \textit{OnUpdate} jednotlivých \enquote{Managerov}, ktorí jej náležia.
\vspace{10pt}
\begin{lstlisting}[label=src:OnUpdate,caption={Odchytenie stlačenia klávesovej skratky v spustenej hre}]
public void OnUpdate() {
    if (Keyboard.current.f11Key.wasPressedThisFrame) {
        if (Keyboard.current.leftShiftKey.isPressed) {
            screenSaved = false;
            StartCoroutine(StartCreateReport());
            return;
        }
    }

    if (screenSaved) {
        ZipAndSendToLinkManager();
        screenSaved = false;
    }
}
\end{lstlisting}

Kód vo výpise \ref{src:OnUpdate} teda každú snímku testuje, či bola stlačená klávesa F11 a to práve v tom danom snímku. Toto zabezpečí, že sa blok kódu tejto podmienky vykoná len raz, bez ohľadu na to, ako dlho užívateľ danú klávesu držal stlačenú. Ak je popri tom stlačená aj klávesa Shift, spustí sa tzv. \enquote{Coroutine}. V tomto prípade je ňou mnou definovaná metóda \textit{StartCreateReport}. Výhoda korutiny spočíva v možnosti pozastaviť vykonávanie svojho kódu. Pozastavenie môže byť na programátorom definovanú dobu alebo do doby než nastane určitá udalosť. V tomto prípade bolo tou udalosťou kompletné vykreslenie aktuálneho snímku a to z dôvodu zachytenia tohto snímku ako obrázku.

Metóda \textit{StartCreateReport} má za úlohu zozbierať rôzne dáta o aplikácií alebo systéme, na ktorom je spustená. Ide o dáta ako verzia aplikácie, pozícia a rotácia kamery v momente vyvolania akcie či posledný záznam v logovacom systéme. Tieto dáta sú následne spolu so spomínanou snímkou obrazovky a naposledy uloženým postupom hrou uložené na disk. Zložka, do ktorej sú súbory uložené závisí od toho, či je hra spustená z editoru Unity alebo samostatne. Takéto vetvenie kódu sa realizuje pomocou direktívy UNITY\_EDITOR, ktorá je spolu s ďalšími platformovo závislými direktívami definovaná samotným editorom. Jednoduchý príklad použitia takýchto direktív demonštruje výpis \ref{src:Pragma}. Nakoľko táto zložka obsahuje celú históriu reportov, jednotlivé reporty majú poradové čísla a každý ďalší dostane pridelené poradové číslo o jedna väčšie ako ten predchádzajúci.
\vspace{10pt}
\begin{lstlisting}[label=src:Pragma,caption={Ukážka použitia direktívy UNITY\_EDITOR}]
#if UNITY_EDITOR
	Debug.Log("Editor");                
#else
    Debug.Log("Standalone");             
#endif
\end{lstlisting}

Následne sa logika aplikácie delí na dve vetvy. Prvá obstaráva vytvorenie lokálneho reportu, druhá vzdialeného. Možnosť vzdialeného nahlasovania chýb, teda odoslanie reportu z PC na ktorom hra nie je spustená bola pridaná až neskôr v súvislosti s prevodom hry na iné platformy. Oba spôsoby odoslania reportu potom demonštruje výpis \ref{src:Report}.

Odoslanie reportu na server z lokálneho PC pokračuje vytvorením tzv. \enquote{Mantis argumentu}. Ide o textový súbor, ktorého obsah je cesta k naposledy vytvorenému reportu. Ten je uložený do zložky, kde sa nachádza spúšťací súbor nástroja HoboThor. Následne je tento nástroj spustený a pokiaľ je pri tomto procese prítomný už spomínaný \enquote{Mantis argument}, nespustí sa hlavné okno aplikácie, ale len okno určené na odoslanie reportu. Po prečítaní obsahu je súbor samozrejme zmazaný, aby neovplyvnil ďalšie spustenie nástroja HoboThor.

Pokiaľ ide o odoslanie reportu zo vzdialeného PC ukázala sa ako problematická doba ukladania snímky obrazovky na disk. Kvôli tomuto problému musí aplikácia najskôr počkať na uloženie súboru a až následne vykonávať ďalšie inštrukcie. Toho som docielil jednoduchou slučkou, ktorá sa sama ukončí v prípade nájdenia požadovaného súboru alebo po pretečení určitého času. To slúži ako ochrana pred zacyklením. 

\vspace{10pt}
\begin{lstlisting}[label=src:Report,caption={Vytváranie lokálneho a vzdialeného reportu}]
// Local report
if (HBTLink_Manager.sender_ServerIP == HBTLink_Manager.Instance.LocalIPAddress().ToString()) {
    string exefile = GameConfiguration.pathConfig.exeFile;
    if (File.Exists(exefile)) {
        var argFile = GameConfiguration.pathConfig.mantisArguments;

        if (File.Exists(argFile))
            File.Delete(argFile);

        File.WriteAllText(argFile, directoryReport.FullName);
        Application.OpenURL(exefile);
    }
}
// Remote report
else {
    float time = 0;
    while (time <= maxWaitTime) {
        yield return new WaitForSeconds(.1f);
        time++;
        if (File.Exists(screenFileName)) {
            screenSaved = true;
            yield break;
        }
    }
}
\end{lstlisting}

Na zmenu hodnoty premennej \textit{screenSaved} zareaguje metóda \textit{OnUpdate} z výpisu \ref{src:OnUpdate} a spustí metódu \textit{ZipAndSendToLinkManager}. Tá pomocou knižnice DotNetZip \cite{DotNetZip} prevedie celú zložku s reportom na zip súbor so zachovaním hierarchickej štruktúry podzložiek a súborov. Následne ho prevedie na reťazec s kódovaním base64 a predá triede HBTLink\_Manager na odoslanie do vzdialeného PC. Táto metóda je znázornená vo výpise \ref{src:Zip}. 

Rreťazec je následne pomocou TCP protokolu odoslaný na IP adresu určenú v konfiguračnom súbore alebo vybratú z prednastavených možností vo vývojárskej konzole počas hrania. Na vzdialenom PC musí byť spustený nástroj HoboThor a \enquote{počúvať} na určenom porte. Dáta sú po prijatí uložené do dočasnej zložky poskytovanej operačným systémom pomocou metódy \textit{Path.GetTempPath} v mennom priestore \textit{System.IO} a následne rozbalené. Cesta k tejto zložke je opäť zapísaná do \enquote{Mantis argumentu} a HoboThor je následne automaticky spustený znova. To vyústi k otvoreniu okna určeného na nahlasovanie chýb a načítaniu dát zo zložky s reportom.
\vspace{10pt}
\begin{lstlisting}[label=src:Zip,caption={Metóda ZipAndSendToLinkManager triedy ReportingManager}]
private void ZipAndSendToLinkManager() {
    string pathToZip = directoryReport.FullName + @"\report.zip";

    using (ZipFile zip = new ZipFile()) {
        var files = Directory.EnumerateFiles(directoryReport.FullName, "*.*", SearchOption.AllDirectories);
        foreach (string file in files) {
            if (file.Contains("Characters"))
                zip.AddFile(file, @"\Saves\Characters");
            else if (file.Contains("Worlds"))
                zip.AddFile(file, @"\Saves\Worlds");
            else
                zip.AddFile(file, "");
        }

        zip.Save(pathToZip);
        Debug.Log("Zipped to " + pathToZip);
    }

    if (File.Exists(pathToZip)) {
        string base64zip = System.Convert.ToBase64String(File.ReadAllBytes(pathToZip));
        HBTLink_Manager.Send_MantisReport(base64zip);
        File.Delete(pathToZip);
    }
}
\end{lstlisting}
\vspace{5pt}

Problém tohto postupu bol spočiatku vo veľkosti vyrovnávacej pamäte na strane prijímateľa, teda nástroja HoboThor, ktorá bola poddimenzovaná. Následné testovanie ukázalo, že spoľahlivá veľkosť tejto pamäte začína až na hodnote 2\textsuperscript{20} bytov v závislosti primárne od veľkosti odosielanej snímky obrazovky. Vytvorenie takejto veľkej vyrovnávacej pamäte a následné uloženie všetkých prijatých dát naraz ale nefungovalo na OS Linux. Testovacia aplikácia na tomto systéme zvládla prijať maximálne 14600 bytov. Táto hodnota odpovedá desaťnásobku MTU balíčku preneseného technológiou Ethernet v2 po odčítaní veľkostí TCP a IP hlavičiek. Veľkosť 1460 bytov sa zvykne nazývať aj MSS. Túto problematiku znázorňuje obrázok \ref{pic:Packet}.
\vspace{-50pt}
\begin{figure}[!htbp]
	\centering
	\includegraphics[width=1\textwidth]{Pictures/packet.png}
	\vspace{-60pt}
	\caption{Dátový balíček \cite{MSS}}
	\label{pic:Packet}
\end{figure}

Riešením bolo použitie vyrovnávacej pamäte o veľkosti 2\textsuperscript{10} bytov a postupné prijímanie dát zo sieťového prúdu pomocou cyklu. Gro tohto postupu je zobrazené vo výpise \ref{src:Stream}.
\vspace{10pt}
\begin{lstlisting}[label=src:Stream,caption={Postupné čítanie dát zo sieťového prúdu}]
TcpClient client = reciever_Listener.AcceptTcpClient();
NetworkStream nwStream = client.GetStream();

while ((i = nwStream.Read(buffer, 0, buffer.Length)) != 0)
{
    data += Encoding.ASCII.GetString(buffer, 0, i);
}
\end{lstlisting}
\vspace{5pt}

Mojou poslednou úlohou v časti reportovacieho systému na strane hry, ktorá prišla ako požiadavka od programátorov bolo pridať možnosť odosielať reporty priamo z editoru bez nutnosti mať spustenú hru. Typický prípad použitia bolo nahlasovanie chýb nájdených popri práci s náhľadom scény. Väčšina kódu bola prebratá z vyššie popísanej časti, museli byť však zmenené niektoré postupy. 

Odchytávanie klávesovej skratky bolo tentoraz realizované natívnym postupom zabudovaným do editora Unity. Stačilo vytvoriť statickú metódu \textit{CreateReport} a nad jej definíciu pridať atribút \enquote{MenuItem} ako znázorňuje výpis \ref{src:UnityReport}. To vyústi k vytvoreniu zástupcu tejto metódy v hornom paneli editora. Pozícia metódy v paneli je určená zadanou cestou v parametri atribútu \enquote{MenuItem}. Za túto cestou je potom možné pridať ľubovoľnú klávesovú skratku, ktorá túto akciu vyvolá.
\vspace{10pt}
\begin{lstlisting}[label=src:UnityReport,caption={Odchytenie stlačenia klávesovej skratky v editore Unity}]
[MenuItem("Tools/HBT/Reporting/Create report #F11")] // # -> Shift
static void CreateReport()
{
    // body...
}
\end{lstlisting}
\vspace{5pt}

Pôvodný postup vytvorenia snímky obrazovky pomocou metódy \textit{CaptureScreenshotAsTexture} bolo nutné nahradiť metódou \textit{ReadScreenPixel}, ktorá ale potrebuje vedieť presnú lokáciu a rozmery okna. Získať tieto údaje sa mi nakoniec podarilo až volaním C++ metód z user32.dll. Počas testovania na 4K monitore sa ukázalo, že tento prístup nevhodne vyhodnocuje veľkosť okna s nastaveným škálovaním v OS Windows. Toto bolo nutné upraviť ručne, čo ukazuje výpis \ref{src:DLL}.
\vspace{10pt}
\begin{lstlisting}[label=src:DLL,caption={Získanie veľkosti okna Unity editoru}]
[DllImport("user32.dll")]
private static extern bool GetWindowRect(IntPtr hwnd, ref Rect rectangle);
[DllImport("user32.dll")]
private static extern IntPtr GetActiveWindow();

private struct Rect {
    public int Left { get; set; }
    public int Top { get; set; }
    public int Right { get; set; }
    public int Bottom { get; set; }
}

private static Rect GetUnityBounds() {
    Rect unityWindowBounds = new Rect();
    float scale = Screen.dpi / 96;

    GetWindowRect(GetActiveWindow(), ref unityWindowBounds);

    unityWindowBounds.Right = (int)(unityWindowBounds.Right / scale);
    unityWindowBounds.Bottom = (int)(unityWindowBounds.Bottom / scale);
    
    return unityWindowBounds;
}
\end{lstlisting}

Na strane Windows Forms aplikácie implementovanej do nástroja HoboThor bolo nutné najskôr vytvoriť sadu tried a enumov, ktoré by po serializácií/deserializácií presne kopírovali štruktúru projektu či reportu s ktorou pracuje služba Mantis Bug Tracker. Následne bolo nutné navrhnúť užívateľské rozhranie. To prechádzalo iteratívnymi zmenami na základe spätnej väzby až do svojej finálnej podoby znázornenej na obrázku \ref{pic:Report}.

\begin{figure}[!htbp]
	\centering
	\setlength{\fboxsep}{0pt}
	\setlength{\fboxrule}{1pt}
	\fbox {
		\includegraphics[width=.98\textwidth]{Pictures/report.png}
	}
	\caption{Užívateľské rozhranie aplikácie Mantis Report}
	\label{pic:Report}
\end{figure}

Po spustení aplikácie sa načíta uložená snímka obrazovky a zobrazí sa v náhľadovom okne na pravej strane. Vzhľadom na to, že v dobe spúšťania tento obrázok ešte nemusí byť plne k dispozícií je táto funkcionalita realizované v separátnom vlákne pomocou tzv. \enquote{Background Workera}. Ten v cykle prehľadáva zložku s reportom kvôli prítomnosti obrázku a až následne, keď je k dispozícií ho zobrazí.

Po načítaní dát z report zložky do polí \enquote{Shrnutí} a \enquote{Popis} sú odoslané dve GET žiadosti na server. Prvá požaduje dáta o užívateľovi, ktorému náleží príslušný api kľúč odoslaný spolu so žiadosťou a druhá požaduje informácie o projekte. Medzi tieto informácie patria aj kategórie evidované pre daný projekt. Tie sú vložené do kombinovaného poľa \enquote{Kategorie}. Tento postup bol zvolený z dôvodu možných budúcich zmien v štruktúre kategórií na serveri. Ostatné kombinované polia boli vyplnené vopred pripravenými enumami. U nich sa žiadna budúca zmena nepredpokladá.

Užívateľ zadá dostupné informácie k nájdenej chybe a report odošle na server. Táto akcia zahŕňa získanie dát zo všetkých dostupných polí a následné vytvorenie inštancie triedy \textit{Issue}, ktorá tieto dáta zapúzdruje. Všetky prílohy určené na odoslanie sú potom uložené do príslušných polí bytov, prevedené na reťazce s kódovaním base64 obdobným postupom ako vo výpise \ref{src:Zip} a predané spomínanej inštancií.

V tomto momente bola aplikácia prakticky hotová ale z QA oddelenia prišla požiadavka na možnosť úpravy obrázka pred odoslaním bez nutnosti použitia externých nástrojov. Vytvoril som teda druhé okno pre túto aplikáciu, ktoré sa otvorí po kliknutí na náhľadový obrázok a umožňuje do neho kresliť. Toto okno je znázornené na obrázku \ref{pic:Paint}. 

\begin{figure}[!htbp]
	\centering
	\includegraphics[width=1\textwidth]{Pictures/pictureEditBox.png}
	\caption{Okno úpravy obrázka aplikácie Mantis Report}
	\label{pic:Paint}
\end{figure}

Postupne bola pridaná podpora viacerých hrúbok a farieb čiar či tlačítko reset, ktoré slúži na návrat k pôvodnému obrázku. Zmeny v tomto okne sú spätne reflektované aj náhľadovým obrázkom v hlavnom okne reportovacej aplikácie. 

Na kreslenie bolo využité vlastné riešenie založené na udalostiach \textit{MouseDown}, \textit{MouseUp} a \textit{MouseMove}. Pri pohybe myši spolu so stlačeným ľavým tlačidlom dôjde k vykresľovaníu čiary medzi dvoma bodmi, čo sa od určitej frekvencie zaznamenávania bodov javí ako súvislý ťah. Tento postup je demonštrovaný vo výpise \ref{src:Paint}.
\vspace{10pt}
\begin{lstlisting}[label=src:Paint,caption={Implementácia kreslenia v prostredí Windows Forms}]
private void pictureBoxBcg_MouseDown(object sender, MouseEventArgs e) {
    moving = true;
    x = e.X;
    y = e.Y;
}

private void pictureBoxBcg_MouseMove(object sender, MouseEventArgs e) {
    if (moving && x != -1 && y != -1) {
        g.DrawLine(pen, new Point(x, y), e.Location);
        x = e.X;
        y = e.Y;
        pictureBoxBcg.Invalidate();
    }
}
private void pictureBoxBcg_MouseUp(object sender, MouseEventArgs e) {
    moving = false;
    x = -1;
    y = -1;
}
\end{lstlisting}
\subsection{Vytváranie \enquote{Patch notes} pre QA oddelenie (GitLogger)}
\label{sec:GitLogger}
\textbf{Časová náročnosť:} \\ Nasadenie: 3 dni, následné úpravy: 1 deň.\\
\textbf{Úvod do problému:} \\ S blížiacim sa dátumom vydania hry sa zvyšuje aj frekvencia testovania a rýchlosť s akou pribúdajú opravy chýb. Medzi jednotlivými zostaveniami aplikácie býva nejaké časové obdobie - zvyčajne jeden týždeň. Toto obdobie je zakončené nahraním najnovšie zostavenej verzie hry na platformu Steam, kde ju môže QA oddelenie začať testovať. Informovanie testerov o najnovších zmenách a opravách môže byť pracné a náchylné na vynechanie niektorých dôležitých vecí. Mojou úlohou bolo tento proces pokiaľ možno čo najviac optimalizovať.\\
\textbf{Navrhované riešenia:} \\ Prvým navrhovaným riešením, ktoré sa už využívalo v niektorých vývojárskych nástrojoch bolo použitie knižnice, ktorá sa po zadaní správnych prihlasovacích údajov pripojí na Git server a prevedie prítomné \textit{commity} na štruktúru tried, s ktorou je potom možné ďalej pohodlne pracovať. Po preskúmaní tohto riešenia sa ukázalo, že jednotlivé knihovne nemajú vyriešenú podporu pripojenia na server pomocou protokolu SSH ale iba HTTPS, čo sa ukázalo ako veľký problém. Prišiel som teda s riešením, ktoré by si stiahlo \textit{commity} iba z lokálneho repozitára a to pomocou PowerShellu v OS Windows.  \\
\textbf{Realizácia:} \\ Po založení testovacieho projektu na platforme .NET bolo mojím prvým krokom zistiť, ako programovo spustiť rôzne skripty a príkazy v programe Windows PowerShell či klasickom príkazovom riadku. Postupne som narazil na triedu \textit{PowerShell} určenú presne pre tento prípad použitia. Pomocou tejto triedy som si vytvoril metódu, ktorá vie spustiť ľubovoľný príkaz a vrátiť jeho výsledok ako pole reťazcov. Táto metóda je znázornená vo výpise \ref{src:Shell}. 

Ako sa ukázalo, Windows PowerShell v predvolenom nastavení pre český jazyk nepoužíva kódovanie UTF-8, čo zapríčinilo nesprávnu interpretáciu znakov s diakritikou. Bolo nutné v nastaveniach systému v sekcií región túto voľbu ručne zapnúť, nakoľko je stále vo fáze vývoja.
\vspace{10pt}
\begin{lstlisting}[label=src:Shell,caption={Metóda na spustenie skriptu v programe Powershell}]
private string[] InvokePowershellScript(string gitCmd) {
    string[] results;
    using (PowerShell powershell = PowerShell.Create()) {
        powershell.AddScript($"cd {projectDirectory}");
        powershell.AddScript(gitCmd);

        results = powershell.Invoke().Select(r => r.ToString()).ToArray();
    }

    return results;
}
\end{lstlisting}

Po vyskúšaní rôznych preddefinovaných variant príkazu \textit{git log} som sa rozhodol zostaviť si vlastný príkaz, nakoľko mi žiadna preddefinovaná varianta úplne nevyhovovala. Hlavným dôvodom bola snaha čo najviac zjednodušiť následnú syntaktickú analýzu. Tento príkaz som sa rozhodol vytvárať dynamicky, aby sa sám aktualizoval po zmene premennej \textit{mainSplitter}. Ukážka tohto postupu je zobrazená vo výpise \ref{src:Log}.
\vspace{10pt}
\begin{lstlisting}[label=src:Log,caption={Dynamické vytváranie vlastného príkazu git log}]
private const char mainSplitter = '&';
private string gitLog = "git log ";

public GitLogger() {
    gitLog += string.Format("--pretty=format:\"%an%{0}%ad%{0}%s\"" +
        " --date=format:'%d.%m.%Y'", ((int)mainSplitter).ToHex());
}
\end{lstlisting}

Následne bolo nutné v cykle prejsť všetky výsledky od najnovšieho \textit{commitu} až po \textit{commit}, ktorý značil posledné zostavenie hry interne dostupné na platforme Steam. Z týchto výsledkov sa odstránili všetky zlúčenia jednotlivých vetiev a ďalšie  \textit{commity}, ktoré neobsahovali ani opravy chýb ani novo pridané vylepšenia. Opravy boli značené tzv. \enquote{bugMarkerom} (@b) a vylepšenia tzv. \enquote{featureMarkerom} (@f). Tých mohlo byť v jednom \textit{commite} hneď niekoľko, preto bol na každý \textit{commit}, ktorý nejakú z týchto značiek obsahoval, aplikovaný regulárny výraz a jednotlivé časti boli ďalej spracovávané samostatne. Tento regulárny výraz zobrazuje výpis \ref{src:Regex}. Každá časť navyše mohla byť rozdelená na viacero menších častí rovnakého druhu pomocou znaku `;`. Jednotlivé elementárne časti boli následne štruktúrovane uložené do súboru.
\vspace{10pt}
\begin{lstlisting}[label=src:Regex,caption={Regulárny výraz na rozdelenie tela \textit{commitu}}]
var matches = Regex.Matches(body, string.Format("({0}|{1})[^@]*", bugMarker, featureMarker));
\end{lstlisting}

Pôvodný prípad použitia mal zahŕňať automatické otvorenie tohto súboru v predvolenom textovom editore a jeho ručné skopírovanie do programu Microsof Teams, ktorý sa používa na komunikáciu vo firme. Rozhodol som sa ale preskúmať možnosti automatizovaného odosielania správ v tejto službe a pokúsil sa implementovať lepšie riešenie.

Služba Microsoft Teams podporuje automatizované posielanie správ okrem iného aj pomocou tzv. \enquote{Webhooks}. Tie sa dajú nakonfigurovať priamo v užívateľskom rozhraní služby a to buď pre konkrétny kanál alebo konverzáciu. \enquote{Webhook} vygeneruje jedinečnú URL adresu, na ktorú je možné posielať POST žiadosti, ktoré sú spomenuté aj v sekcií \ref{sec:QACode}. Telo takejto žiadosti sa potom v aplikácií Microsoft Teams zobrazí ako správa odoslaná \enquote{Webhookom}. Dáta sú prenášané ako štruktúrovaný JSON reťazec. Okrem jednoduchých správ je možné posielať aj formátovaný text pomocou značkovacieho jazyka Markdown, prípadne tzv. karty. 

Pomocou nástroja Postman som vo formáte JSON vytvoril dva návrhy takejto karty a nechal kolegov rozhodnúť o tom, ktorý sa nakoniec použije. Podľa zvoleného návrhu som následne implementoval triedu \textit{Message} tak, aby svojou vnútornou štruktúrou odpovedala štruktúre danej karty a bolo možné ju použiť na serializáciu či deserializáciu. 

Základnú kostru karty, ktorá sa počas vykonávania programu nebude meniť, som uložil do súboru. Pri každej novej POST žiadosti je tento súbor prečítaný a jeho obsah deserializovaný na novú inštanciu triedy \textit{Message}. Do tela správy sú vložené dáta získané z \textit{commitov} po syntaktickej analýze a následne je celá správa odoslaná do \enquote{Webhooku} metódu uvedenou vo výpise \ref{src:Shell}. Tento postup demonštruje výpis \ref{src:Message}. 
\vspace{10pt}
\begin{lstlisting}[label=src:Message,caption={Vytvorenie a odoslanie správy do služby Microsoft Teams}, escapechar={|}]
Message message = Message.FromJson(File.ReadAllText(pathToJSON));
Content content = message.Attachments[0].|\color{words}Content|;

content.Title = header;
content.Sections[0].ActivityText = PrintListToJsonString(features);
content.Sections[1].ActivityText = PrintListToJsonString(bugs);

// cmdBegin == "Invoke-RestMethod -Method post -ContentType 'Application/Json; charset=UTF-8' -Body '";
string command = cmdBegin + Serialize.ToJson(message) + "' -Uri " + webHook;
string result = InvokePowershellScript(command)[0];
\end{lstlisting}

Metóda \textit{PrintListToJsonString} použitá vo výpise  \ref{src:Message} pridá do dát značky jazyka Markdown, čím sa ešte upraví finálny vzhľad. Zároveň pomocou regulárneho výrazu \mbox{``\#\\d+``} nahradí všetky výskyty číselných reťazcov začínajúcich znakom `\#` za klikateľný odkaz na stránku konkrétneho reportu v službe Mantis Bug Tracker. To je užitočné v prípadoch keď \textit{commit} priamo opravuje nejakú nahlásenú chybu. Vytvorená karta je znázornená na obrázku \ref{pic:Logger}.

\begin{figure}[!htbp]
	\centering
	\includegraphics[width=1\textwidth]{Pictures/gitlogger.png}
	\caption{Vytvorená karta v aplikácií Microsoft Teams}
	\label{pic:Logger}
\end{figure}

Poslednou pridanou funkcionalitou bolo, aby sa táto karta neposielala pri každom zostavení hry na serveri ale iba vtedy, keď je to skutočne žiadúce. Aplikácia teda prečíta obsah súboru BuildSettings.asset a ak v ňom nájde reťazec ``sendPatchNotesToTeams: 1`` vykoná odoslanie. V opačnom prípade sú dáta len štruktúrovane zapísané na disk. Súbor BuildSettings.asset je podrobne popísaný v sekcií \ref{sec:BuildServer}.

Aplikácia bola nasadená ako externý súbor, ktorý je spustený službou Gitlab CI/CD bližšie popísanou v sekcií \ref{sec:GitLab}.
\subsection{Automatizované zostavenie hry na serveri (Build Server)}
\label{sec:BuildServer}
\textbf{Časová náročnosť:} \\ Nasadenie: 6 dní, následné úpravy podľa požiadaviek: 2 dni.\\
\textbf{Úvod do problému:} \\ Zostavenie projektu Hobo: Tough Life môže v závislosti od rôznych faktorov trvať aj viac ako hodinu čistého času. Počas tejto doby samozrejme nie je možné do projektu zasahovať, čo do značnej miery obmedzuje možnosť ďalej vyvíjať. Zostavenie navyše často končí neúspechom a je nutné po vykonaní opráv proces opakovať. Mojou úlohou bolo teda preskúmať rôzne možnosti ako toto zostavenie vykonať automaticky a bez zablokovania pracovnej stanice. \\
\textbf{Navrhované riešenia:} \\ Prvou možnosťou, ktorá sa však hneď zavrhla bolo použitie riešenia priamo od firmy Unity Technologies a síce ich ponúkaného \enquote{Unity Cloud Buildu}. Táto možnost je dostupná za určitý poplatok závislý od veľkosti repozitára. Tá je v našom prípade značná, čo by toto riešenie predražilo a zároveň by nahrávanie repozitára mimo lokálnu sieť bolo časovo náročné. Po preskúmaní rôznych riešení použiteľných na lokálnom serveri sa finálny výber zúžil na služby Jenkins, TeamCity a Gitlab \mbox{CI/CD}. Voľba nakoniec padla na Gitlab CI/CD nakoľko na firemnom serveri je využívaná služba Gitlab a očakávala sa teda najlepšia kompatibilita spomedzi ponúkaných možností.\\
\textbf{Realizácia:} \\ Kvôli už spomínanému rozsahu hry nie je vhodné testovať automatizované zostavenie priamo na nej, bolo teda nutné vytvoriť testovací projekt. Zostavenie tohto projektu na pracovnej stanici pomocou metódy \textit{BuildPipeline.BuildPlayer} prebehlo úspešne. Táto metóda prijíma niekoľko nastavení ako napríklad cieľová platforma, scény určené na zostavenie či cestu k zostavenému spustiteľnému súboru a následne sama toto zostavenie vykoná. Kľúčom bolo teda túto metódu spolu s nejakou ďalšou logikou zavolať v rámci reakcie na nejakú udalosť, ktorá nastane na serveri. Táto udalosť môže byť napríklad zlúčenie zmien v rôznych vetvách či nahranie najnovších zmien v kóde do určitej vetvy vo vzdialenom repozitári. Druhú spomínanú variantu sme sa rozhodli využiť a teda spustiť zostavenie po vykonaní príkazu \textit{push} do vetvy master, ktorá je hlavnou vetvou vo verzovacom systéme.

Po úspešnom zostavení projektu na pracovnej stanici pomocou skriptu bolo teda ďalším krokom nasadenie na server. K nasadeniu bolo nutné vytvoriť konfiguračný súbor .gitlab-ci.yml, v ktorom sú uložené príkazy, ktoré majú byť vykonané ako reakcia na konkrétnu udalosť. Tieto príkazy sú organizované do etáp. Každá etapa sa potom stará o určitú sadu úloh, ktoré spolu súvisia. Príkladom by mohli byť etapy ako otestuj, zostav či nasaď. Na prvý pohľad je jasné, čo bude mať daná etapa na starosť. 

V našom prípade bola nutná iba etapa \enquote{build}, je ale možné, že do budúcna sa tento počet bude zvyšovať. Obsah súboru .gitlab-ci.yml, ktorý bol použitý v projekte je možné vidieť vo výpise \ref{src:YML}. V tomto súbore môže byť nakonfigurovaná aj pomerne zložitá logika, nakoniec sa však z rôznych dôvodov osvedčilo túto logiku presunúť do separátneho batch súboru a ten len z .gitlab-ci.yml spustiť. Jedným z týchto dôvodov bolo napríklad, že po neúspešnom zostavení hry sa etapa \enquote{build} ukončila úspešne, čo je pomerne zásadný problém, ktorý sa mi nepodarilo vyriešiť. Naopak použitie batch súboru umožnilo jednoducho ukončiť etapu s hodnotou navrátenou enginu Unity. Typicky išlo o kompilačné chyby. Tento postup sa osvedčil aj v prípade chýb prejavených počas zostavovania projektu. V tomto prípade bolo možné nepriamo použiť hodnotu \textit{result} zo štruktúry \textit{BuildReport.summary}, ktorú vracia metóda \textit{BuildPipeline.BuildPlayer}. 

Príkazy zadané v súbore .gitlab-ci.yml vykonáva tzv \enquote{Gitlab runner}. Ten je možné stiahnuť z oficiálnych stránok ako spustiteľný súbor a pre zabezpečenie správneho fungovania ho spúšťať po štarte systému. Najskôr je však nutné ho zaregistrovať na konkrétny projekt alebo niekoľko projektov. Registrácia prebieha v niekoľkých jednoduchých krokoch po spustení programu \enquote{Gitlab runner} z príkazového riadku spolu s príkazom \textit{register}. Jeden z krokov vyžaduje od užívateľa tzv. token, ten je možné nájsť v nastaveniach repozitára vo webovej aplikácií Gitlab. Posledným krokom je potom zvolenie tzv. \enquote{executora}, pomocou ktorého bude  \enquote{Gitlab runner} vykonávať zadané príkazy. V našom prípade bola zvolená možnosť \textit{shell}, čo značí prosté vykonávanie príkazov v príkazovom riadku lokálneho PC.

\vspace{10pt}
\begin{lstlisting}[language=yml,label=src:YML,caption={Obsah súboru .gitlab-ci.yml}]
variables:
  GIT_CLONE_PATH: $CI_BUILDS_DIR\
  GIT_CLEAN_FLAGS: none

unity-build: 
  stage: build
  only:
    - master
  script:
    - C:\PerunCreative\Projekty\Hobo\Build\runBuild.bat
  tags: 
    - unity
\end{lstlisting}

Registrácia neprebehla úspešne z dôvodu, že server, na ktorom je uložený náš projekt nemá doménu a ani základný SSL certifikát. Ten sa nakoniec podarilo vytvoriť a vlastným podpisom pomocou nástroja OpenSSL. Výsledný certifikát potom musel byť uložený aj na strane servera aj na strane \enquote{Gitlab runnera} aby sa  zabezpečila úspešná registrácia.

Ďalším problémom bola prednastavená \textit{clone/fetch} zložka, do ktorej si \enquote{Gitlab runner} sťahuje najnovšie zmeny na projekte pred zahájením zostavovania. Pri veľkosti nášho repozitára, ktorej hodnota presahuje 100GB by bolo zdĺhavé a nehospodárne mať na serveri dve takéto separátne zložky. Problém by nastal aj pri manuálnych zásahoch do repozitára, ktoré by v réžií samotného Gitlabu boli veľmi zdĺhavé, a tak by sa museli vykonávať ručne na dvoch miestach. Gitlab CI/CD neumožňuje zadanie ľubovolnej cesty do premennej \textit{GIT\_CLONE\_PATH} v súbore .gitlab-ci.yml. Tá sa musí vždy odvíjať od nastavenia \textit{CI\_BUILD\_DIR}. Hodnotu tejto premennej sa napokon po niekoľkých neúspešných pokusoch podarilo nastaviť priamo v konfiguračnom súbore \enquote{Gitlab Runnera}.

Ďalším krokom bolo vytvorenie samotného batch súboru, ktorý bude spúštaný z .gitlab-ci.yml a ktorý bude zároveň spúštať engine za účelom zostavenia projektu. Z toho vyplýva nutnosť mať vždy k dispozícií cestu k editoru Unity. Ten je ale často aktualizovaný a cesta je teda závislá od jeho aktuálnej verzie. Za týmto účelom bol použitý textový súbor ProjectVersion.txt, ktorý obsahuje informácie o aktuálnej verzií projektu. Pokiaľ sa verzia projektu a editoru nebude zhodovať vyústi to do chyby, kvôli neplatnej ceste čo slúži ako impulz k aktualizovaniu editoru na serveri.

Engine Unity ponúka širokú škálu parametrov s ktorými môže byť spustený. Okrem cesty k projektu a cesty k logovaciemu súboru boli použité parametre ako \textit{batchmode}, ktorý spustí program bez užívateľského rozhrania a parameter \textit{quit}, ktorý editor ukončí po vykonaní všetkých naprogramovaných akcií. Nakoniec je ešte nutné uviesť statickú metódu, ktorá má byť zavolaná. Identifikátor tejto metódy musí byť uvedený vrátane všetkých menných priestorov, do ktorých metóda náleží. Návratová hodnota z editoru je následne uložená do premennej \textit{ERRORLEVEL}. Podľa tejto premennej je ukončené vykonávanie batch súboru a zároveň podľa nej .gitlab-ci.yml nastaví výsledok etapy. Po úspešnom zostavení je ešte spustený súbor GitLogger.exe, ktorého účel bol podrobne vysvetlený v sekcií \ref{sec:GitLogger}. Obsah celého batch súboru potom znázorňuje výpis \ref{src:batch}.

\vspace{5pt}
\begin{lstlisting}[style=Batch,label=src:batch,caption={Skript zabezpečujúci zostavenie hry na serveri}]
@ECHO off
SET project_path="C:\PerunCreative\Projekty\Hobo\HoboTL"
SET path_to_log="C:\PerunCreative\Projekty\Hobo\Build\build.log"

SET /p var=<%project_path%\ProjectSettings\ProjectVersion.txt
SET version=%var:~17%
ECHO Project version is: %version%

C:\"Program Files"\Unity\Hub\Editor\%version%\Editor\Unity.exe -quit -batchmode -logfile %path_to_log% -projectPath %project_path% -executeMethod Dev.Build.BuildScript.Build

IF %ERRORLEVEL% GTR 0 (
	ECHO An error with errorlevel %ERRORLEVEL% occurs
	ECHO Check logfile build.txt in project folder for more details
) ELSE (
	ECHO Build succeeded
	START "" "GitLogger.exe"
)

EXIT %errorlevel%
\end{lstlisting}

Metóda \textit{BuildScript.Build} volá metódu \textit{BuildScript.InternalBuild} s parametrom \textit{closeAfterBuild} nastaveným na hodnotu \textit{true}. Toto riešenie bolo zvolené z dôvodu, aby sa pri manuálnom spustení zostavovania pomocou skriptu, napríklad z horného menu editora Unity, editor neukončil. Úloha metódy \textit{InternalBuild} je potom nájsť a načítať dáta z tzv. \enquote{Scriptable Objectu}, čo je uvedené vo výpise \ref{src:asset}, a následne tieto dáta predať metóde \textit{SetUpPlatforms}. Návratová hodnota tejto metódy je potom použítá ako návratová hodnota celého programu.

\vspace{10pt}
\begin{lstlisting}[label=src:asset,caption={Načítanie dát zo scriptable objectu}]
buildSettings = AssetDatabase.LoadAssetAtPath<BuildSettings>("Assets/Settings/BuildSettings.asset");
\end{lstlisting}

\enquote{Scriptable Object} BuildSettings.asset slúži ako dátové úložisko všetkých nastavení týkajúcich sa automatizovaného zostavenia. S týmto objektom je potom možné pohodlne pracovať priamo z užívateľského rozhrania enginu nakoľko som implementoval tzv \enquote{Custom editor}. Ten je znázotnený na obrázku \ref{pic:Custom}.

\begin{figure}[!htbp]
	\centering
	\includegraphics[width=.90\textwidth]{Pictures/buildDetail.png}
	\caption{Custom editor pre scriptable object BuildSettings.asset}
	\label{pic:Custom}
\end{figure}

Samotná trieda \textit{BuildSettings} dedí z triedy \textit{ScriptableObject} a je iba súhrnom relatívne veľkého množstva serializovaných premenných a enumov. \enquote{Custom editor} je potom realizovaný ako trieda \textit{BuildSettingsEditor}, ktorá je potomkom triedy \textit{Editor}. Táto trieda sa nachádza v preddefinovanej \textit{Assembly-CSharp-Editor}, preto je nutné potomkov triedy \textit{Editor} presunúť do zložky Editor alebo ich kód obaliť do direktívy UNITY\_EDITOR zobrazenej aj vo výpise \ref{src:Pragma}. To zabráni vyvolaniu chyby pri pokuse o zostavenie projektu nakoľko \textit{Assembly-CSharp-Editor} z pochopiteľných dôvodov nie je prítomná v zostavenej verzií hry. Základná kostra triedy \textit{BuildSettings}, ktorá vykreslí iba premennú \textit{platforms} je zobrazená vo výpise \ref{src:bseditor}.

\vspace{10pt}
\begin{lstlisting}[label=src:bseditor,caption={Kostra triedy určenej pre vykreslenie vlastného okna v Editore Unity}]
[CustomEditor(typeof(BuildSettings))]
public class BuildSettingsEditor : Editor {
    private BuildSettings settings;
    private SerializedProperty platforms;
    
    private void OnEnable() {
        platforms = serializedObject.FindProperty("platforms");
    }
    public override void OnInspectorGUI() {
        settings = AssetDatabase.LoadAssetAtPath<BuildSettings>("Assets/Settings/BuildSettings.asset");
        
        EditorGUILayout.PropertyField(platforms);
        serializedObject.ApplyModifiedProperties();
    }
}
\end{lstlisting}

Finálna trieda, použitá v projekte bola okrem pridania ostatných premenných doplnená o nadpisy, medzery medzi skupinami a v neposlednej rade aj o varovné hlásenia pri nastavení polí \textit{Platform} či \textit{Scenes} na hodnotu \textit{Nothing}. Varovné hlásenie sa objaví aj pri nastavení tzv. \enquote{scripting backendu} na hodnotu inú ako IL2CPP, čo je dôležité nastavenie z hľadiska výkonu finálneho produktu. Pri tomto nastavení je IL kód pred vytvorením spustiteľného súboru prevedený na kód jazyka \mbox{C++ \cite{IL2CPP}}. Ukážka takéhoto varovania je uvedená na obrázku \ref{pic:Warr}.

\begin{figure}[!htbp]
	\centering
	\includegraphics[width=1\textwidth]{Pictures/warr.png}
	\caption{Varovanie v custom editore}
	\label{pic:Warr}
\end{figure}

Metóda \textit{SetUpPlatforms} spomenutá vyššie zo získaných dát od metódy \textit{InternalBuild} extrahuje tzv. masky. Maska platformy určuje, na ktoré platformy sa bude hra zostavovať a maska scény, ktoré scény budú v zostavenom súbore prítomné. Princíp použitia takejto masky je demonštrovaný na získavaní scén zvolených v objekte BuildSettings.asset vo výpise \ref{src:scenes}. Tieto scény sú potom predávané ako argument príslušným zostavovacím metódam. 

\vspace{10pt}
\begin{lstlisting}[label=src:scenes,caption={Extrahovanie zvolených scén pomocou masky}]
private static string[] SetUpScenes() {
    Array enumScenes = Enum.GetValues(typeof(BuildSettings.Scene));
    List<string> scenesToBuild = new List<string>();

    foreach (var item in enumScenes) {
        if (IsSelected(sceneMask, (BuildSettings.Scene)item)) {
            scenesToBuild.Add("Assets/Scenes/" + item + ".unity");
        }
    }

    return scenesToBuild.ToArray();
}

private static bool IsSelected(int EnumMask, Enum enumValue) {
    int tempMask = 1 << Convert.ToInt32(enumValue);
    
    return (EnumMask & tempMask) == 0 ? false : true;
}
\end{lstlisting}

Obdobne prebieha aj práca s maskou platformy. Ak metóda \textit{IsSelected} vráti hodnotu \textit{true} pri dotazovaní na konkrétnu platformu, je spustená príslušná zostavovacia metóda. Tá vykoná samotné zostavenie pomocou metódy \textit{BuildPipeline.BuildPlayer} s nastaveniami špecifickými pre danú platformu. Návratová hodnota sa potom vráti späť metóde \textit{SetUpPlatforms} a pokiaľ neznačí úspech je vyhodená výnimka s popisom, že zostavenie na danej platforme zlyhalo. Ak všetky zvolené zostavenia skončia úspechom, je úspešne ukončený aj celý program. Gro  metódy na zostavenie hry pre OS Windows je znázornený vo výpise \ref{src:bwin}. 

Ako je možné vidieť, metóda \textit{BuildWindows} dostane ako prvý argument nastavenia špecifické pre danú platformu, v tomto prípade je to platforma Windows. Tieto nastavenia momentálne obsahujú iba cestu k zložke do ktorej má byť zostavenie pre danú platformu uložené. Toto riešenie bolo dočasne zvolené z dôvodu, že nie je možné predikovať špecifiká, ktoré si zostavenie na niektoré konzolové platformy bude vyžadovať. Keď budú tieto informácie dostupné plánuje sa zjednotenie všetkých zostavovacích metód do jednej. Táto metóda potom bude ako prvý argument prijímať generalizáciu nejakých konkrétnych nastavení a bude riadená dátami získanými z týchto nastavení.

\vspace{10pt}
\begin{lstlisting}[label=src:bwin,caption={Extrahovanie zvolených scén pomocou masky}]
private static bool BuildWindows(WindowsSettings settings, string[] scenes) {

	// ...
	
    BuildPlayerOptions options = new BuildPlayerOptions();
    options.scenes = scenes;
    options.locationPathName = path + Application.productName + ".exe";
    options.targetGroup = BuildTargetGroup.Standalone;
    options.target = BuildTarget.StandaloneWindows64;
    options.options = GetBuildOptions(); // Development, AllowDebugging, ...

    BuildReport report = BuildPipeline.BuildPlayer(options);
    
    return report.summary.result == BuildResult.Succeeded ? true : false;
}
\end{lstlisting}

Postupne boli do projektu pridané aj ďalšie možnosti zostavenia. Možnosť \enquote{scriptsOnly} značí, že budú nanovo prekompilované všetky skripty bez nutnosti zostaviť celý projekt nanovo. Táto možnosť ale nie je k dispozícií pre \enquote{scripting backend} IL2CPP, takže je určená len na vývojárske využitie, kde je nutné robiť veľa iteratívnych zmien v krátkom čase a hneď ich aj testovať. Druhou implementovanou možnosťou bolo v už zostavenom projekte aktualizovať len tzv. \enquote{bundles}. \enquote{Bundles} sú binárne súbory, ktoré môžu obsahovať napríklad nové textúry, modely či konverzácie a načítavajú sa dynamicky počas vykonávania programu \cite{Bundles}. Tieto možnosti teda pridávaju ďalšiu vrstvu optimalizácie tým, že kompletné zostavenie nastane až keď je to nevyhnutné.

\section{Optimalizácia a prevod hry na ďalšie platformy}
\label{sec:Port}
\subsection{Optimalizácia a refaktorovanie kódu}
\label{sec:optim}
\textbf{Časová náročnosť:} \\ 4 dni.\\
\textbf{Úvod do problému:} \\ S rastúcim výkonom výpočtovej techniky sa neustále znižuje dôraz na optimalizáciu a efektivitu. Herný vývoj je ale jedna z disciplín, v ktorých hrá optimalizácia veľmi dôležitú úlohu aj dnes. Rovnako ako narastá výkon tak narastajú aj požiadavky hráčov na vyššiu fotorealistickosť grafiky či viac vykreslených snímkov za sekundu. S tým ide ruku v ruke aj vývoj v ďalších oblastiach hardvéru ako sú napríklad monitory. Najmodernejšie sériovo vyrábané svojimi parametrami presahujú rozlíšenie 4k a obnovovaciu frekvenciu 240Hz. Na dosiahnutie hodnoty 60 snímok za sekundu je potom nutné vykonať všetky potrebné algoritmy v rámci 16 milisekúnd, čo nie je vždy jednoduché. Mojou úlohou bolo teda identifikovať potenciálne úzke hrdlá a pokiaľ možno ich aj optimalizovať \\
\textbf{Navrhované riešenia:} \\ Ako som už spomínal v sekcií \ref{sec:QACode} hra Hobo: Tough Life je postavená na hierarchickej štruktúre manažérov. Hlavný manažér obsahuje metódu \textit{Update} a v nej sú postupne volané metódy \textit{OnUpdate} všetkých ostatných manažérov. Z pohľadu výkonu je toto najkritickejšie miesto nakoľko metóda \textit{Update} je vykonávaná počas vykreslenia každej jednej snímky. Prvou vecou, na ktorú bolo nutné sa zamerať bola práve táto hierarchická štruktúra. Druhým návrhom bolo použiť nástroj Unity Profiler, ktorého účelom je zaznamenávať rôzne údaje o výkone hry do jednotlivých grafov. Takto je napríklad možné zobraziť aj presnú metódu, ktorá bola volaná v momente, keď nastal pád snímok. Treťou a poslednou vecou, na ktorú som sa rozhodol zamerať bola celková mikrooptimalizácia založená na vyhľadávaní a oprave drobných neoptimalizovaných častí kódu pochádzajúcich prevažne z ranného štádia vývoja.  \\
\textbf{Realizácia:} \\ Prvým krokom bolo teda preskúmanie štruktúry metód volaných pri vykresľovaní každej snímky. Veľký prepad snímok na konkrétnom mieste, napríklad pri komunikácií s nejakým NPC je problém,  pokiaľ však takáto situácia nastáva len veľmi zriedka, je výhodnejšie snažiť sa skôr o optimalizáciou často volaných metód. Tým sa zdvihne priemerná hodnota snímok za sekundu a už rozdiel v ráde nižších jednotiek býva v niektorých kritických bodoch hry signifikantný. V často volaných metódach, ako napríklad už spomenutá metóda \textit{Update}, by sa prakticky nemalo vyskytovať vytváranie nových premenných referenčného typu. Tieto premenné odkazujú na pamäťový priestor vytvorený na halde a spravidla zaberajú rádovo viac pamäte ako bežné, napríklad celočíselné premenné. Táto pamäť alokovaná na halde musí byť následne uvoľnená. Narozdiel od jazykov ako C++, v jazyku C\# sa o toto uvoľňovanie pamäte stará tzv \enquote{Garbage Collector} alebo GC. Ten je volaný v pravidelných intervaloch, ale je možné ho zavolať aj predčasne, napríklad v momente načítavania novej lokácie, keď prudký pád snímok za sekundu nebude hrať žiadnu rolu. Z toho teda vyplýva, že čím menej pamäte bude nutné týmto spôsobom uvoľňovať, tým menší dopad na výkon a prepady snímok bude GC mať. Alokácia novej pamäte by teda mala nastávať pri inicializácií a v niektorých ďalších situáciach, ale rozhodne nie pri vykresľovaní každej snímky. Aby sa ešte zmenšila nutnosť alokovania novej pamäte, je v projekte použitý aj tzv \enquote{Object Pool}. Ten slúži na recykláciu určitých objektov, aby ich nebolo nutné znova vytvárať. 

Ďalšou vecou, ktorá by sa mala nachádzať v takýchto metódach čo najmenej sú pochopiteľne cykly. Nie vždy sa im dá vyhnúť, je však vhodné zvážiť použitie iného spôsobu, napríklad korutiny. Týmto spôsobom by sa počet vykonávaní nejakého cyklu mohol zredukovať napríklad na štvrtinu, čo by vytvorilo možnosť niektoré akcie striedať medzi sebou.

Po podrobnom preskúmaní týchto metód, som nenašiel žiadne závažné úzke hrdlo. Toto zistenie nebolo až tak prekvapivé, nakoľko hra prešla počas svojho vývoja niekoľkými optimalizačnými cyklami s dôrazom práve na tieto miesta. Rovnako som bola aj dopredu upozornený, že problém optimalizácie je do veľkej miery hľadanie tzv. \enquote{ihly v kope sena}.

Druhou optimalizačnou stratégiou bolo použitie nástroja Unity Profiler. Tento nástroj pracuje v dvoch režimoch - štandardnom a hlbokom. Štandardný režim menej ovplyvňuje finálny výkon hry, v praxi sa mi ale veľmi neosvedčil. Umožňoval síce základnú detekciu problémov, od určitej hĺbky zanorenia ale nie je možné dohľadať konkrétne volané metódy. Užitočnosť tohto režimu sa ale ukázala pri hľadaní alokovanej pamäte v danom snímku. Hodnoty namerané v potenciálne problematickom mieste a síce pri otváraní inventára znázorňuje obázok \ref{pic:Prof}.

\begin{figure}[!htbp]
	\centering
	\includegraphics[width=1\textwidth]{Pictures/profiler.png}
	\caption{Namerané hodnoty z nástroja Unity Profiler}
	\label{pic:Prof}
\end{figure}

Po otvorení inventára dôjde k vytvoreniu veľkého množstva objektov, ktoré sa týkajú uživateľského rozhrania. Najväčšiu časť z alokovaných objektov tvorili užívateľom získané predmety. Po porade s kolegami sme dospeli k záveru, že by to bolo možné optimalizovať len nejakou formou stránkovania, čo by ale znamenalo nutnosť prepracovať celý doterajší systém, a to sa ukázalo z časového hľadiska nerealizovateľné. Čo sa ostatných prvkov užívateľského rozhrania inventára týka, žiadny svojou náročnosťou výrazne neprevyšoval ostatné, takže sa upustilo od ďalšieho skúmania. Veľká alokácia pamäte bola ešte samozrejme prítomná pri štarte hry. To sa nám podarilo z velkej miery optimalizovať.

Následné využívanie hlbokého režimu profilera ukazovalo niekoľko potenciálnych problematických miest, všetky sa ale ukázali ako slepé uličky. Niektoré boli spôsobené spustením hry v rámci editoru a v samostatnej zostavenej verzií ich nebolo možné zreprodukovať, iné boli nevyhnutné pre samotný chod hry, prípadne zabezpečovali vykresľovanie grafiky samotnej.

Následné mikrooptimalizácie boli zamerané tzv \enquote{cachovanie premenných}, prevod \textit{foreach} cyklov na klasické \textit{for} cykly, prednastavenie kapacity rôznych dátových štruktúr pri ich vytváraní, používanie lokálneho súradnicového systému na úkor globálneho pokiaľ to bolo možné či zabránenie zbytočnej serializácií premenných, ktoré nutne serializované byť nemuseli.

\enquote{Cachovanie premenných} je jednoduchá technika pri ktorej sa ukladajú získané dáta do nejakej dočasnej premennej aby sa s nimi mohlo ďalej pracovať bez nutnosti neustále sa na ne dotazovať znova. Efektivita takéhoto prístupu sa naviac ukazuje v spojení s \textit{for} cyklom. Namiesto toho, aby sa kód každú iteráciu cyklu vždy dotazoval na dĺžku nejakej dátovej štruktúry je táto dĺžka uložená do premennej a vždy len prečítaná.

\textit{Foreach} cyklus bol v priebehu vývoja postupne nahrádzaný \textit{for} cyklom. Dôvodom bolo, že cyklus \textit{for} vykazuje prakticky vždy lepšie výsledky z hľadiska výkonu. Vo väčšine kľúčových miest bol nahradený už v dobe keď som začínal s projektom pracovať, niekoľko desiatok takých, kde ho bolo potrebné nahradiť sa ale našlo. Išlo o prípady, kde sa tento cyklus používa v rámci čistej hry pre jedného hráča. Zasahovať do cyklov v rámci vývojárskych nástrojov by z hľadiska výkonu nijak nepomohlo a nezasahovalo sa z tohto pohľadu ani do zložky hry pre viac hráčov.

Prednastavenie kapacity dátových štruktúr je taktiež veľmi užitočná optimalizácia. Obyčajné pole, ktoré je na projekte preferované, pokiaľ ho je možné použiť, sa vytvára s kapacitou takou, aby dokázalo bezpečne uložiť všetky dáta. Dátové štruktúry ako \textit{List} či \textit{Dictionary} majú naproti tomu výhodu, že môžu svoju kapacitu postupne zväčšovať. Časté zväčšovanie je ale veľmi náročné z hľadiska výpočtového výkonu nakoľko je nutné po presiahnutí pôvodnej kapacity vytvoriť na pozadí novú dátovú štruktúru s väčšou kapacitou a jednotlivé prvky do nej skopírovať. Pokiaľ teda programátor má aspoň približnú predstavu o počte budúcich uložených prvkov je vhodné tomu priblížiť aj prednastavenú kapacitu. V niektorých prípadoch som skutočne našiel takéto prípady a následne ich opravil.

Posledné dve vykonávané mikrooptimalizácie úzko súvisia s enginom Unity. Prvá z nich je uprednostnenie lokálneho súradnicového systému oproti globálnemu. To je z dôvodu, že lokálny súradnicový systém je relatívny k rodičovskému objektu a globálne koordináty sa musia vždy vyrátať zo všetkých rodičovských objektov až ku koreňovému objektu, čo značí omnoho vyššiu náročnosť na výpočtový výkon. Čo sa serializácie objektov týka, Unity engine automaticky serializuje všetky verejné premenné objektu. Pokiaľ nie je nutné tieto premenné serializovať nemali by byť označené ako verejné. Tento prístup je zlý aj z hľadiska zapúzdrenia. V projekte sa od ranného vývoja vyskytovali niektoré čisto verejné triedy, mojou úlohou bolo teda skontrolovať, čo je potrebné serializovať a čo nie. Následne bolo nutné upraviť modifikátor prístupu podľa potreby a prakticky všetky verejné premenné nahradiť za tzv \enquote{Properties}. Pri tomto postupe bolo nutné dbať na serializované dáta. Niektoré z týchto dát boli nastavované a následne ladené podľa potreby priamo v editore a strata týchto dát by predstavovala veľký problém. Dáta sa aj automaticky zmažu po premenovaní danej premennej a následnej kompilácií. 

Po jednom nechcenom premenovaní bolo nutné ručne obnovovať niektoré dôležité dáta ako napríklad identifikátory objektov, našťastie sa to stalo iba pri jednej dátovej štruktúre, ktorá nebola veľmi obsiahla. Problémy nastali aj pri niektorých nevhodne \enquote{zacachovaných} premenných, prípadne pri prevode cyklov. Po ich následnej úprave a prekontrolovaní všetkých zmien Fbola optimalizácia a refaktorovanie ukončené z dôvodu nenájdenia ďalších veľkých problémov a nutnosti venovať sa ďalším projektom. Predtým ale ešte došlo k aplikácií automatizovaných nástrojov na formátovanie kódu či vymazanie nevyužívaných \textit{using} príkazov.

\subsection{Prevod hry na OS Linux}
\label{sec:linux}
\textbf{Časová náročnosť:} \\ 6 dní.\\
\textbf{Úvod do problému:} \\ Hra Hobo: Tough Life vychádza primárne na platforme Steam. Steam bol dlhodobo synonymom pre hranie na OS Windows, dnes ale podporuje aj ďalšie operačné systémy ako Linux či MacOS. Podpora zo strany distribútora je však iba jedna časť. O samotný prevod hry sa musí postarať samotný vývojár či externé štúdio. Podpora však musí byť zaistená aj zo strany enginu, na ktorom je hra vytvorená. Engine Unity umožňuje pomerne jednoduchý prevod hry na iné platformy po doinštalovaní príslušného modulu a zvolení správnych nastavení zostavenia. Sú však veci, ktoré sa chovajú rozdielne na rôznych platformách a mojou úlohou teda bolo tieto veci nájsť, nahlásiť a prípadne aj opraviť. V dobe písania tohto textu sa jednalo iba o prevod na OS Linux, po ostrom vydaní sa však plánujú aj vydania na konzolové platformy.\\
\textbf{Realizácia:} \\ Testovanie, prípadne oprava chýb, ktoré sa vyskytli v hre spustenej na OS Linux by sa realizovalo len veľmi zle bez prístupu k PC s týmto OS. Narozdiel od OS Windows poskytuje Linux veľké množstvo distribúcií s rôznou úrovňou podpory aj zameraním. Pre účely testovania hry bola zvolená distribúcia Ubuntu z dôvodu, že patrí medzi tie najobľúbenejšie pre bežného používateľa bez špeciálnych požiadaviek. Následne bolo nutné rozhodnúť akým spôsobom bude tento OS nainštalovaný. Distribúcia spustená z prenosného disku rovnako ako virtualizovaná verzia majú rôzne obmedzenia a nedokážu spoľahlivo nasimulovať reálne použitie. Bol teda zvolený tzv. \enquote{dual boot} teda nainštalovania OS Linux \enquote{vedľa} hlavného OS na pracovnej stanici. Inštalácia prebehla v poriadku, problém bol však so spúšťaním. PC bez opýtania bootoval do OS Windows a nebolo možné vybrať OS pri štarte. Tento problém sa nakoniec podarilo vyriešiť zmenou poradia bootovania v rámci jedného disku. Táto možnosť bola pomerne dobre schovaná v BIOSe a bolo nutné uviesť Ubuntu na prvé miesto. To spôsobí, že pri každom štarte sa spustí program GRUB zodpovedný práve za zavádzanie OS a v rámci neho je možné vybrať, ktorý OS bude aktuálne spustený.

Operačný systém bol teda pripravený a mohlo sa prejsť na zostavenie hry. Po niekoľkých neúspešných pokusoch sa zistilo, že IL2CPP zostavenie nie je momentálne možné aj napriek nainštalovanému príslušnému modulu. Jednalo sa o chybu, ktorú som nahlásil spoločnosti Unity Technologies a nasledujúce zostavenia už prebiehali výlučne v režime mono. 

Zostavené verzie hry sa ukladajú na server pripojený do lokálnej siete. Na tomto serveri je nainštalovaný bežný OS Windows a dáta sú prístupné pomocou mechanizmu zdieľanej zložky. Na prístup k tejto zložke z OS Linux bol použitý program Gigolo, ktorý na tento úkon využíva štandard SAMBA. Stačilo sa teda pripojiť na server a spustiť zostavený program.

Tento prístup fungoval s testovacou aplikáciou, problém však nastal pri pokuse spustiť hru priamo vo virtuálnom súborovom systéme GVfs. Hra sa spustila ale všetky pokusy o načítanie herného sveta skončili chybovou hláškou. Možným riešením sa ukázalo kopírovanie zostavenej hry do lokálneho PC. To však nie je veľmi efektívne nakoľko bolo niekoľkokrát denne nutné presúvať herné súbory, ktorých veľkosť presahuje 20GB. Postupne sa zistilo, že spustená hra nedokáže v GVfs získať výlučný zámok na súbory s uloženými pozíciami. Tie sa generujú automaticky pri pokuse o vytvorenie nového herného sveta. Tento problém sa nakoniec podarilo vyriešiť zásahom do kódu hry. Do vytvárania \textit{FileStreamu} zo súboru bolo nutné explicitne pridať parametre \textit{FileMode.Open}, \textit{FileAccess.Read} a \textit{FileShare.Read}. Po tomto zásahu už bolo možné vstúpiť do hry a testovať.

Testovanie ukázalo hneď niekoľko závažných problémov. Prvým viditeľným na prvý pohľad bola absencia intra. Intro je realizované ako videoklip a úlohou enginu Unity je ho len prehrať. Aby sa garantovalo správne prehratie na všetkých platformách zdrojový videoklip musí prejsť tzv. \enquote{transcodingom}. Táto operácia je voliteľná, v projekte sa však využívala. \enquote{Transcoding} má hneď niekoĺko nastaviteľných možností a najdôležitejšou je výstupný kodek. Ten bol nastavený na automatický výber podľa platformy, táto možnosť však nefungovala korektne a bolo nutné explicitne zvoliť kodek vp8, ktorý má natívnu podporu na všetkých cieľových platformách.

Druhý problém sa prejavil pri pokuse zmeniť rozlíšenie hry. Užívateľ môže rozlíšenie nastaviť v nastaveniach hry pomocou šípok doprava a doľava. Tieto rozlíšenia sú zoradené podľa zobrazeného počtu pixelov vzostupne a nie je možné preskakovať mimo poradia. Problém sa prejavoval pri pokuse zmeniť rozlíšenie z 640x480 na 1920x1080 a z rozlíšenia 1680x1050 opäť na 1920x1080. Táto hodnota je natívne rozlíšenie monitora, na ktorom bola hra spustená. Ukázalo sa, metóda \textit{Screen.currentResolution} dostupná v engine Unity vracala rozdielne hodnoty v závislosti od operačného systému. Na OS Windows táto metóda vracala nastavené rozlíšenie hry, ktoré mohol užívateľ ovplyvniť a na OS Linux vracala rozlíšenie monitora. Táto metóda bola použitá z dôvodu optimalizácie a kontrolovala, či zmena rozlíšenia v hre zapríčinená užívateľským kliknutím na šípku nastala medzi dvoma rozdielnymi rozlíšeniami. Nakoľko ale na OS Linux táto metóda vracala vždy 1920x1080, pokusy zmeniť rozlíšenie práve na túto hodnotu vždy zlyhali. Problém vyriešila mierne odlišná implementácia tejto logiky založená na metóde \textit{Screen.safeArea}.

Po vytvorení a vstupe do nového herného sveta sa ako ďalší problém ukázal počet snímkov za sekundu. Ten v priemere dosahoval 15fps, čo nie je hrateľná hodnota. Pripojenie hry na vzdialený PC so spusteným programom Unity Profiler, ktorý bol spomenutý už v sekcií \ref{sec:optim} ukázalo, že ohromné množstvo výkonu využíva metóda zodpovedná za integráciu so službou Steam. Tento problém som nahlásil kolegovi a ten musel aktualizovať Steam API na najnovšiu verziu. Problém bol v tom, že aktuálne využívaná verzia bola stará niekoľko rokov a za tú dobu API prešlo razantnými zmenami v implementácií, ktoré bolo nutné zohľadniť aj v kóde hry.

Posledným závažným problémom bola nemožnosť otáčania hernej kamery resp. rozhliadnutia sa v plnom rozsahu 360$^{\circ}$. Reálne dostupný uhol bol pocitovo asi polovičný. Kurzor myši je v hre skrytý pokiaľ hráč neotvorí menu alebo inventár a práve v inventári bolo vidieť, že moment, kedy prestane byť možné ďalej sa rozhliadať je zároveň momentom, kedy kurzor narazí na kraj obrazovky. Na OS Windows je tento kurzor uzamknutý v strede pokiaľ nie je viditeľný a keď užívateľ otvorí inventár zobrazí sa v strede obrazovky a užívateľ s ním môže manipulovať. Na OS Linux bolo nutné explicitne pri zneviditeľnení kurzora vždy nastaviť aj vlastnosť \textit{Cursor.lockState} na hodnotu \textit{CursorLockMode.Locked}. To umožnilo pohyb kamery v celom rozsahu, stále však boli mierne odlišnosti medzi chovaním na OS Windows a OS Linux. Túto diverzitu sme sa nakoniec rozhodli zachovať, nakoľko nijak neovplyvňuje zážitok z hry.

Jedným z menších problémov, ktoré sa ešte podarilo nájsť bol problém s veľkosťou kurzoru v rámci minihry stieranie žrebu. Ten bol niekoľkonásobné väčší ako na OS Windows. Kurzor mal v rámci tejto minihry nastavený tzv \enquote{sprite} namiesto predvoleného výzoru a na OS Linux nefungovalo správne škálovanie tohto \enquote{spritu}. Tento problém sa podarilo opraviť zmenou veľkosti zdroja priamo na požadovanú hodnotu, ktorá vyhovovala na všetkých operačných systémoch bez nutnosti ďalších úprav tejto veľkosti kódom.

V hre sa aj naďalej vyskytovali menšie problémy, bola však bez problémov hrateľná. Niektoré ďalšie nájdené problémy boli pomocou aplikácie \enquote{Mantis Report} zo sekcie \ref{sec:Report} nahlásené a ďalšie testovanie či opravy chýb boli prenechané povolanejším osobám.

\subsection{Implementácia Epic Online Services}
\label{sec:implEOS}
\textbf{Časová náročnosť:} \\ Nasadenie: 3 dni.\\
\textbf{Úvod do problému:} \\ Ako som spomenul v sekcií \\
\textbf{Navrhované riešenia:} \\ Nakoľko bola \\
\textbf{Realizácia:} \\ Pri preskúmavaní mož

\section{Ostatné projekty}
\label{sec:Others}
\subsection{Systém líhania hráčskej postavy}
\label{sec:sleep}
\textbf{Časová náročnosť:} \\ Nasadenie: 3 dni.\\
\textbf{Úvod do problému:} \\ Ako som spomenul v sekcií \\
\textbf{Navrhované riešenia:} \\ Nakoľko bola \\
\textbf{Realizácia:} \\ Pri preskúmavaní mož
asd

\chapter{Teoretické a praktické znalosti a zručnosti získané v priebehu štúdia uplatnené v priebehu odbornej praxe}
\label{sec:techZruc}
\chapter{Znalosti a zručnosti chýbajúce v priebehu odbornej praxe}
\label{sec:coNeviem}
\chapter{Dosiahnuté výsledky v priebehu odbornej praxe a celkové zhodnotenie}
\label{sec:Results}

\printbibliography[title={Literatúra}, heading=bibintoc]

%\appendix
%\chapter{Zdrojový kód triedy RestPosition}
%\lstinputlisting[label=src:lihanie,caption={Algoritmus na zistenie správnej polohy spiacej postavy}]{Ext/RestPosition.cs}
\end{document}
